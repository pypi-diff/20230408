# Comparing `tmp/finlab-0.3.9-cp39-cp39-win_amd64.whl.zip` & `tmp/finlab-0.4.0-cp39-cp39-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,36 +1,47 @@
-Zip file size: 384878 bytes, number of entries: 34
--rw-rw-rw-  2.0 fat     2135 b- defN 22-Oct-13 04:01 finlab/__init__.py
--rw-rw-rw-  2.0 fat   202752 b- defN 22-Jul-18 13:30 finlab/aes.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat    22051 b- defN 22-Sep-26 20:51 finlab/backtest.py
--rw-rw-rw-  2.0 fat   130560 b- defN 22-Oct-13 13:42 finlab/backtest_core.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat     1424 b- defN 22-Jul-18 13:20 finlab/backtest_old.py
--rw-rw-rw-  2.0 fat      915 b- defN 22-Jul-18 13:20 finlab/cells.py
--rw-rw-rw-  2.0 fat    24735 b- defN 22-Oct-13 10:42 finlab/data.py
--rw-rw-rw-  2.0 fat    27138 b- defN 22-Oct-13 04:01 finlab/dataframe.py
--rw-rw-rw-  2.0 fat    80714 b- defN 22-Jul-18 13:20 finlab/ffn_core.py
--rw-rw-rw-  2.0 fat    72704 b- defN 22-Oct-13 13:42 finlab/mae_mfe.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat      460 b- defN 22-Jul-18 13:20 finlab/mae_mfe.pxd
--rw-rw-rw-  2.0 fat     4216 b- defN 22-Jul-25 16:04 finlab/market_info.py
--rw-rw-rw-  2.0 fat    36481 b- defN 22-Oct-03 17:22 finlab/plot.py
--rw-rw-rw-  2.0 fat   228864 b- defN 22-Oct-03 17:27 finlab/report.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat     5132 b- defN 22-Jul-18 13:20 finlab/utils.py
--rw-rw-rw-  2.0 fat    19968 b- defN 22-Jul-18 13:31 finlab/utils_core.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat     7426 b- defN 22-Oct-03 17:22 finlab/analysis/__init__.py
--rw-rw-rw-  2.0 fat     5007 b- defN 22-Sep-26 20:51 finlab/analysis/inequalityAnalysis.py
--rw-rw-rw-  2.0 fat     4395 b- defN 22-Sep-26 20:51 finlab/analysis/liquidityAnalysis.py
--rw-rw-rw-  2.0 fat        0 b- defN 22-Jul-18 13:20 finlab/online/__init__.py
--rw-rw-rw-  2.0 fat    10983 b- defN 22-Oct-13 04:01 finlab/online/base_account.py
--rw-rw-rw-  2.0 fat      252 b- defN 22-Jul-18 13:20 finlab/online/enums.py
--rw-rw-rw-  2.0 fat     6170 b- defN 22-Oct-13 04:01 finlab/online/fugle_account.py
--rw-rw-rw-  2.0 fat    14940 b- defN 22-Oct-13 13:23 finlab/online/order_executor.py
--rw-rw-rw-  2.0 fat    13122 b- defN 22-Oct-13 04:01 finlab/online/panel.py
--rw-rw-rw-  2.0 fat     6697 b- defN 22-Oct-13 04:01 finlab/online/sinopac_account.py
--rw-rw-rw-  2.0 fat     5361 b- defN 22-Oct-03 17:22 finlab/online/utils.py
--rw-rw-rw-  2.0 fat        0 b- defN 22-Jul-18 13:20 finlab/optimize/__init__.py
--rw-rw-rw-  2.0 fat     8687 b- defN 22-Jul-25 16:04 finlab/optimize/combinations.py
--rw-rw-rw-  2.0 fat    35823 b- defN 22-Oct-13 13:42 finlab-0.3.9.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     3642 b- defN 22-Oct-13 13:42 finlab-0.3.9.dist-info/METADATA
--rw-rw-rw-  2.0 fat      100 b- defN 22-Oct-13 13:42 finlab-0.3.9.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        7 b- defN 22-Oct-13 13:42 finlab-0.3.9.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     2774 b- defN 22-Oct-13 13:42 finlab-0.3.9.dist-info/RECORD
-34 files, 985635 bytes uncompressed, 380500 bytes compressed:  61.4%
+Zip file size: 391402 bytes, number of entries: 45
+-rw-rw-rw-  2.0 fat     2450 b- defN 23-Apr-08 21:08 finlab/__init__.py
+-rw-rw-rw-  2.0 fat   206848 b- defN 23-Apr-08 21:13 finlab/aes.cp39-win_amd64.pyd
+-rw-rw-rw-  2.0 fat    22598 b- defN 23-Apr-08 21:08 finlab/backtest.py
+-rw-rw-rw-  2.0 fat   133632 b- defN 23-Apr-08 21:13 finlab/backtest_core.cp39-win_amd64.pyd
+-rw-rw-rw-  2.0 fat     1424 b- defN 23-Apr-08 21:08 finlab/backtest_old.py
+-rw-rw-rw-  2.0 fat      915 b- defN 23-Apr-08 21:08 finlab/cells.py
+-rw-rw-rw-  2.0 fat    29089 b- defN 23-Apr-08 21:08 finlab/data.py
+-rw-rw-rw-  2.0 fat    29056 b- defN 23-Apr-08 21:08 finlab/dataframe.py
+-rw-rw-rw-  2.0 fat    80750 b- defN 23-Apr-08 21:08 finlab/ffn_core.py
+-rw-rw-rw-  2.0 fat    73216 b- defN 23-Apr-08 21:13 finlab/mae_mfe.cp39-win_amd64.pyd
+-rw-rw-rw-  2.0 fat      460 b- defN 23-Apr-08 21:08 finlab/mae_mfe.pxd
+-rw-rw-rw-  2.0 fat     3757 b- defN 23-Apr-08 21:08 finlab/market_info.py
+-rw-rw-rw-  2.0 fat    36059 b- defN 23-Apr-08 21:08 finlab/plot.py
+-rw-rw-rw-  2.0 fat   166912 b- defN 23-Apr-08 21:13 finlab/report.cp39-win_amd64.pyd
+-rw-rw-rw-  2.0 fat     5132 b- defN 23-Apr-08 21:08 finlab/utils.py
+-rw-rw-rw-  2.0 fat    19968 b- defN 23-Apr-08 21:13 finlab/utils_core.cp39-win_amd64.pyd
+-rw-rw-rw-  2.0 fat     7287 b- defN 23-Apr-08 21:08 finlab/analysis/__init__.py
+-rw-rw-rw-  2.0 fat     1988 b- defN 23-Apr-08 21:08 finlab/analysis/alphaBetaAnalysis.py
+-rw-rw-rw-  2.0 fat     1449 b- defN 23-Apr-08 21:08 finlab/analysis/drawdownAnalysis.py
+-rw-rw-rw-  2.0 fat     5007 b- defN 23-Apr-08 21:08 finlab/analysis/inequalityAnalysis.py
+-rw-rw-rw-  2.0 fat     4626 b- defN 23-Apr-08 21:08 finlab/analysis/liquidityAnalysis.py
+-rw-rw-rw-  2.0 fat    12343 b- defN 23-Apr-08 21:08 finlab/analysis/maeMfeAnalysis.py
+-rw-rw-rw-  2.0 fat     3618 b- defN 23-Apr-08 21:08 finlab/analysis/periodStatsAnalysis.py
+-rw-rw-rw-  2.0 fat      704 b- defN 23-Apr-08 21:08 finlab/ml/__init__.py
+-rw-rw-rw-  2.0 fat    15448 b- defN 23-Apr-08 21:08 finlab/ml/feature.py
+-rw-rw-rw-  2.0 fat     2404 b- defN 23-Apr-08 21:08 finlab/ml/label.py
+-rw-rw-rw-  2.0 fat    17707 b- defN 23-Apr-08 21:08 finlab/ml/qlib.py
+-rw-rw-rw-  2.0 fat     3131 b- defN 23-Apr-08 21:08 finlab/ml/utils.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Apr-08 21:08 finlab/online/__init__.py
+-rw-rw-rw-  2.0 fat     8155 b- defN 23-Apr-08 21:08 finlab/online/base_account.py
+-rw-rw-rw-  2.0 fat    12766 b- defN 23-Apr-08 21:08 finlab/online/binance_account.py
+-rw-rw-rw-  2.0 fat     7264 b- defN 23-Apr-08 21:08 finlab/online/dashboard.py
+-rw-rw-rw-  2.0 fat      263 b- defN 23-Apr-08 21:08 finlab/online/enums.py
+-rw-rw-rw-  2.0 fat    12824 b- defN 23-Apr-08 21:08 finlab/online/fugle_account.py
+-rw-rw-rw-  2.0 fat    17102 b- defN 23-Apr-08 21:08 finlab/online/order_executor.py
+-rw-rw-rw-  2.0 fat    13122 b- defN 23-Apr-08 21:08 finlab/online/panel.py
+-rw-rw-rw-  2.0 fat     8537 b- defN 23-Apr-08 21:08 finlab/online/sinopac_account.py
+-rw-rw-rw-  2.0 fat     5432 b- defN 23-Apr-08 21:08 finlab/online/utils.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Apr-08 21:08 finlab/optimize/__init__.py
+-rw-rw-rw-  2.0 fat     8815 b- defN 23-Apr-08 21:08 finlab/optimize/combinations.py
+-rw-rw-rw-  2.0 fat    35823 b- defN 23-Apr-08 21:13 finlab-0.4.0.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     3787 b- defN 23-Apr-08 21:13 finlab-0.4.0.dist-info/METADATA
+-rw-rw-rw-  2.0 fat      100 b- defN 23-Apr-08 21:13 finlab-0.4.0.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        7 b- defN 23-Apr-08 21:13 finlab-0.4.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     3698 b- defN 23-Apr-08 21:13 finlab-0.4.0.dist-info/RECORD
+45 files, 1025673 bytes uncompressed, 385600 bytes compressed:  62.4%
```

## zipnote {}

```diff
@@ -45,26 +45,59 @@
 
 Filename: finlab/utils_core.cp39-win_amd64.pyd
 Comment: 
 
 Filename: finlab/analysis/__init__.py
 Comment: 
 
+Filename: finlab/analysis/alphaBetaAnalysis.py
+Comment: 
+
+Filename: finlab/analysis/drawdownAnalysis.py
+Comment: 
+
 Filename: finlab/analysis/inequalityAnalysis.py
 Comment: 
 
 Filename: finlab/analysis/liquidityAnalysis.py
 Comment: 
 
+Filename: finlab/analysis/maeMfeAnalysis.py
+Comment: 
+
+Filename: finlab/analysis/periodStatsAnalysis.py
+Comment: 
+
+Filename: finlab/ml/__init__.py
+Comment: 
+
+Filename: finlab/ml/feature.py
+Comment: 
+
+Filename: finlab/ml/label.py
+Comment: 
+
+Filename: finlab/ml/qlib.py
+Comment: 
+
+Filename: finlab/ml/utils.py
+Comment: 
+
 Filename: finlab/online/__init__.py
 Comment: 
 
 Filename: finlab/online/base_account.py
 Comment: 
 
+Filename: finlab/online/binance_account.py
+Comment: 
+
+Filename: finlab/online/dashboard.py
+Comment: 
+
 Filename: finlab/online/enums.py
 Comment: 
 
 Filename: finlab/online/fugle_account.py
 Comment: 
 
 Filename: finlab/online/order_executor.py
@@ -81,23 +114,23 @@
 
 Filename: finlab/optimize/__init__.py
 Comment: 
 
 Filename: finlab/optimize/combinations.py
 Comment: 
 
-Filename: finlab-0.3.9.dist-info/LICENSE
+Filename: finlab-0.4.0.dist-info/LICENSE
 Comment: 
 
-Filename: finlab-0.3.9.dist-info/METADATA
+Filename: finlab-0.4.0.dist-info/METADATA
 Comment: 
 
-Filename: finlab-0.3.9.dist-info/WHEEL
+Filename: finlab-0.4.0.dist-info/WHEEL
 Comment: 
 
-Filename: finlab-0.3.9.dist-info/top_level.txt
+Filename: finlab-0.4.0.dist-info/top_level.txt
 Comment: 
 
-Filename: finlab-0.3.9.dist-info/RECORD
+Filename: finlab-0.4.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## finlab/__init__.py

```diff
@@ -1,46 +1,55 @@
 import os
-import time
 import logging
 import threading
+from . import market_info
+from . import dataframe
+from . import data
+from getpass import getpass
+
 
 # Get an instance of a logger
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger(__name__)
 
-__version__ = '0.3.9'
+__version__ = '0.4.0'
 
 
 class LoginPanel():
 
     def __init__(self):
         pass
 
     def gui_supported(self):
         try:
-            from IPython.display import IFrame, display, clear_output
-            return True
+            if "VSCODE_PID" in os.environ:
+                return False # vscode not support getpass and display at the same time
+            else:
+                return True
         except:
             return False
 
     def display_gui(self):
 
-        from IPython.display import IFrame, display, HTML, clear_output
+        from IPython.display import IFrame, display, clear_output
         iframe = IFrame(
             f'https://ai.finlab.tw/api_token/?version={__version__}', width=620, height=300)
         display(iframe)
 
-        token = input('請從 https://ai.finlab.tw/api_token 複製驗證碼: \n')
-
+        token = getpass('請從 https://ai.finlab.tw/api_token 複製驗證碼: \n')
         clear_output()
         self.login(token)
 
     def display_text_input(self):
-        token = input('請從 https://ai.finlab.tw/api_token 複製驗證碼:\n')
+        print('請從 https://ai.finlab.tw/api_token 複製驗證碼:\n')
+        token = getpass('驗證碼：')
         self.login(token)
+        print('之後可以使用以下方法自動登入')
+        print('import finlab')
+        print('finlab.login("YOUR APITOKEN")')
 
     @staticmethod
     def login(token):
         # set token
         token = token[:64]
         os.environ['finlab_id_token'] = token
         print('輸入成功!')
@@ -52,22 +61,24 @@
     可以至 [api_token查詢頁面](https://ai.finlab.tw/api_token/) 獲取api_token，傳入函數後執行登錄動作。
     之後使用Finlab模組的會員功能時，系統就不會自動跳出請求輸入api_token的[GUI頁面](https://ai.finlab.tw/api_token/)。
     若傳入的api_toke格式有誤，系統會要求再次輸入。
 
     Args:
         api_token (str): FinLab api_token
     """
-    if api_token is None:
-        lp = LoginPanel()
-        if lp.gui_supported():
-            lp.display_gui()
-        else:
-            lp.display_text_input()
+    lp = LoginPanel()
+
+    if api_token:
+        lp.login(api_token)
+        return
+
+    if lp.gui_supported():
+        lp.display_gui()
     else:
-        LoginPanel.login(api_token)
+        lp.display_text_input()
 
 
 def get_token():
     """取得登錄會員的finlab_id。
 
     若未登錄過，會跳出登錄頁面請求登錄。
```

## finlab/backtest.py

```diff
@@ -1,8 +1,7 @@
-import re
 import warnings
 import datetime
 import numpy as np
 import pandas as pd
 from typing import Union
 from pandas.tseries.offsets import DateOffset
 from pandas.tseries.frequencies import to_offset
@@ -89,42 +88,47 @@
             position.values,
             position.index.view(np.int64),
             position.columns.astype(str).values,
             resample_dates
             ]
 
 def sim(position: Union[pd.DataFrame, pd.Series],
-        resample=None, resample_offset=None,
-        trade_at_price='close',
-        position_limit=1, fee_ratio=1.425/1000,
-        tax_ratio=3/1000, name=None, stop_loss=None,
-        take_profit=None, touched_exit=False,
-        retain_cost_when_rebalance=False, live_performance_start=None,
-        mae_mfe_window=0, mae_mfe_window_step=1, market='AUTO', upload=True):
+        resample:Union[str, None]=None, resample_offset:Union[str, None] = None,
+        trade_at_price: Union[str, pd.DataFrame] = 'close',
+        position_limit:float=1, fee_ratio:float=1.425/1000,
+        tax_ratio: float=3/1000, name:str='未命名', stop_loss: Union[float, None]=None,
+        take_profit: Union[float, None]=None, touched_exit: bool=False,
+        retain_cost_when_rebalance: bool=False, live_performance_start:Union[str, None]=None,
+        mae_mfe_window:int=0, mae_mfe_window_step:int=1, market:Union[str, market_info.MarketInfo]='AUTO', upload:bool=True):
 
     """Simulate the equity given the stock position history. 回測模擬股票部位所產生的淨值報酬率。
 
     Args:
 
         position (pd.DataFrame or pd.Series): Dataframe of the stock market position where index is date and columns are stock_id. Each row represents a stock portfolio, where the values are perentages. Negative values represent short position. If any sum of row is larger than 1, the normalization is perform, i.e., (1, 2) becomes (0.33, 0.66).
 
-            買賣訊號紀錄。True 為持有， False 為空手。 若選擇做空position，只要將 sim(position) 改成負的 sim(-position.astype(float))即可做空。 系統預設使用資料為台股與加密貨幣，若要使用美股或其他市場，將資料格式設定同為台股範例即可，index為datetime格式，column為文字格式的標的代號，注意每日自動更新服務不適用台股與加密貨幣的資料。
+            買賣訊號紀錄。True 為持有， False 為空手。 若選擇做空position，只要將 sim(position) 改成負的 sim(-position.astype(float))即可做空。
 
         resample (str or None): rebalance position only on specified frequency.
 
             交易週期。將 position 的訊號以週期性的方式論動股票，預設為每天換股。其他常用數值為 W、 M 、 Q （每週、每月、每季換股一次），也可以使用 W-Fri 在週五的時候產生新的股票清單，並且於下週交易日下單。
-
+            - `D`: Daily
             - `W`: Weekly
             - `W-Wed`: Every Wednesday
             - `M`: Monthly
             - `MS`: Start of every month
             - `ME`: End of every month
-            - `Q`: Quaterly
-            - `QS`: Start of every month
-            - `QE`: End of every month
+            - `Q`: Quarterly
+            - `QS`: Start of every quarter
+            - `QE`: End of every quarter
+            !!!note
+                'D'與'None'的差別？
+                resample='D' 的意義為每天隨股價變化做再平衡，就算當天股票清單沒變，但股票漲跌後，部位大小會變化，而 resample='D' 會強制再平衡，平均分散風險。
+
+                但是當 resample=None 的話，假如清單不變，則不會強制再平衡，只有清單改變時，才做再平衡。適用情境在較常選到大波段標的的趨勢策略，較有機會將強勢股留下，而不會汰強留弱做再平衡。
 
         resample_offset (str or None): add time offset to resample the position.
             交易週期的時間位移，例如。
 
             - '1D': 位移一天
             - '1H': 位移一小時
         trade_at_price (str or pd.DataFrame): rebalance on market 'close' or 'open'.
@@ -147,63 +151,63 @@
         take_profit (float): exit when stock return larger than a specific amount. i.e., 0.3 means +30%
             停利基準，預設為None，不執行停利。範例：0.1，代表從再平衡開始， 10% 時產生出場訊號。
         touched_exit (bool): `True`: exit immediately whenever stop loss or take profit price is touched. `False`: exit tomorrow if the price touches stop loss or take profit. 是否在回測時，使用觸價停損停利？
         retain_cost_when_rebalance (bool): 預設回測時，會將進場股票進場成本更新到到新的 rebalance 的當天價格，假如希望保留原本的進場價格當成停損停利的依據，可以設定為 `True`
         live_performance_start (bool): 策略建構的日期，例如 `2022-01-01` 此日期之前，策略未撰寫，此日期之後則視為與實單有類似效果，實際不影響回測的結果，單純紀錄而已。
         mae_mfe_window (int): 計算mae_mfe於進場後於不同持有天數下的數據變化，主要應用為edge_ratio (優勢比率)計算。預設為0，則Report.display_mae_mfe_analysis(...)中的edge_ratio不會顯現。
         mae_mfe_window_step (int): 與mae_mfe_window參數做搭配，為時間間隔設定，預設為1。若mae_mfe_window設20，mae_mfe_window_step設定為2，相當於python的range(0,20,2)，以2日為間距計算mae_mfe。
-        market (str or class(finlab.market_info.MarketInfo)): 可選擇`'TWSTOCK', 'CRYPTO'`，分別為台股或加密貨幣，
+        market (str or MarketInfo): 可選擇`'TW_STOCK', 'CRYPTO'`，分別為台股或加密貨幣，
                                                               或繼承 finlab.market_info.MarketInfo 開發回測市場類別。
         upload (bool): 上傳策略至finlab網站，預設為True，上傳策略。範例： False，不上傳，可用 finlab.backtest.sim(position, upload=False, ...).display() 快速檢視策略績效。
     Returns:
         (finlab.analysis.Report):回測數據報告
     Examples:
         Assume the history of portfolio is construct as follows: When market close on 2021-12-31, the portfolio {B: 0.2, C: 0.4} is calculated. When market close on 2022-03-31, the portfolio {A:1} is calculated.
 
         |            | Stock 2330 | Stock 1101 | Stock 2454 |
         |------------|------------|------------|------------|
         | 2021-12-31 | 0%         | 20%        | 40%        |
-        | 2022-03-31 | 100%       | 0          | 0          |
+        | 2022-03-31 | 100%       | 0%         | 0%         |
+        | 2022-06-30 | 100%       | 0%         | 0%         |
 
         With the portfolio, one could backtest the equity history as follows:
 
         ``` py
         import pandas as pd
         from finlab import backtest
 
         position = pd.DataFrame({
-            '2330': [0, 1],
-            '1101': [0.2, 0],
-            '2454': [0.4, 0]
-        }, index=pd.to_datetime(['2021-12-31', '2022-03-31']))
+            '2330': [0, 1, 1],
+            '1101': [0.2, 0, 0],
+            '2454': [0.4, 0, 0]
+        }, index=pd.to_datetime(['2021-12-31', '2022-03-31', '2022-06-30']))
 
         report = backtest.sim(position)
         ```
 
 
     """
 
+    # todo: dataframe astype
+    
+
     # check version
     check_version()
 
     # auto detect market type
     if market == 'AUTO':
-        market = 'TWSTOCK'
-
-        if isinstance(position, pd.DataFrame) and (position.columns.str.find('USDT') != -1).any():
-            market = 'CRYPTO'
-        if isinstance(position, pd.Series) and 'USDT' in position.name:
-            market = 'CRYPTO'
+        if isinstance(trade_at_price, str):
+            market = 'TW_STOCK'
 
     # get market position according to market type
     if isinstance(market, str):
-        assert market in ['TWSTOCK', 'CRYPTO']
+        assert market in ['TW_STOCK', 'AUTO']
         market = {
-            'TWSTOCK': market_info.TWMarketInfo,
-            'CRYPTO': market_info.CryptoMarketInfo,
+            'TW_STOCK': market_info.TWMarketInfo,
+            'AUTO': market_info.MarketInfo
         }[market]
 
     # determine trading price
     price = trade_at_price
     if isinstance(trade_at_price, str):
         price = market.get_price(trade_at_price, adj=True)
 
@@ -225,75 +229,74 @@
     # check position types
     if isinstance(position, pd.Series):
         if position.name in price.columns:
             position = position.to_frame()
         else:
             raise Exception('Asset name not found. Please asign asset name by "position.name = \'2330\'".')
 
-    # check name is valid
-    if name:
-        head_is_eng = len(re.findall(
-            r'[\u0041-\u005a|\u0061-\u007a]', name[0])) > 0
-        has_cn = len(re.findall('[\u4e00-\u9fa5]', name[1:])) > 0
-        if head_is_eng and has_cn:
-            raise Exception('Strategy Name Error: 名稱如包含中文，需以中文當開頭。')
-        for c in '()[]+-|!@#$~%^={}&*':
-            name = name.replace(c, '_')
-
     # check position is valid
     if position.abs().sum().sum() == 0 or len(position.index) == 0:
         raise Exception('Position is empty and zero stock is selected.')
 
     # format position index
     if isinstance(position.index[0], str):
         position = FinlabDataFrame(position).index_str_to_date()
 
+    position.iloc[0] = 0
+
     # if position date is very close to price end date, run all backtesting dates
     assert len(position.shape) >= 2
     delta_time_rebalance = position.index[-1] - position.index[-3]
     backtest_to_end = position.index[-1] + \
         delta_time_rebalance > price.index[-1]
 
-    position = position[position.index <= price.index[-1]]
+
+    tz = position.index.tz
+    now = datetime.datetime.now(tz=tz)
+
+    position = position[(position.index <= price.index[-1]) | (position.index <= now)]
     backtest_end_date = price.index[-1] if backtest_to_end else position.index[-1]
 
     # resample dates
     dates = None
-    next_trading_date = position.index[-1].tz_localize(None)
+    next_trading_date = position.index[-1]
     if isinstance(resample, str):
 
         warning_resample(resample)
 
         # add additional day offset
         offset_days = 0
         if '+' in resample:
             offset_days = int(resample.split('+')[-1])
             resample = resample.split('+')[0]
         if '-' in resample and resample.split('-')[-1].isdigit():
             offset_days = -int(resample.split('-')[-1])
             resample = resample.split('-')[0]
 
         # generate rebalance dates
-        dates = pd.date_range(
-            position.index[0], position.index[-1]+ datetime.timedelta(days=720), freq=resample, tz=position.index.tzinfo)
-        dates += DateOffset(days=offset_days)
+        alldates = pd.date_range(
+            position.index[0], 
+            position.index[-1] + datetime.timedelta(days=720), 
+            freq=resample, tz=tz)
+
+        alldates += DateOffset(days=offset_days)
+
         if resample_offset is not None:
-            dates += to_offset(resample_offset)
-        dates = [d for d in dates if position.index[0]
+            alldates += to_offset(resample_offset)
+
+        dates = [d for d in alldates if position.index[0]
                  <= d and d <= position.index[-1]]
 
         # calculate the latest trading date
         next_trading_date = min(
-                set(pd.date_range(position.index[0],
-                    datetime.datetime.now(position.index.tzinfo)
-                    + datetime.timedelta(days=720),
-                    freq=resample)) - set(dates))
+           set(alldates) - set(dates))
 
         if dates[-1] != position.index[-1]:
             dates += [next_trading_date]
+
     elif resample == None:
         # user set resample to None. Rebalance everyday might cause over transaction.
         # remove rebalance date if portfolio is the same.
         position = position.loc[position.diff().abs().sum(axis=1) != 0]
 
     if stop_loss is None or stop_loss == 0:
         stop_loss = 1
@@ -303,70 +306,99 @@
 
     if dates is not None:
         position = position.reindex(dates, method='ffill')
 
     encryption = download_backtest_encryption()
 
     if encryption == '':
-      return
+        print('Cannot perform backtest, permission denied.')
+        return
 
     creturn_value = backtest_(*arguments(price, high, low, open_, position, dates),
                               encryption=encryption,
                               fee_ratio=fee_ratio, tax_ratio=tax_ratio,
                               stop_loss=stop_loss, take_profit=take_profit,
                               touched_exit=touched_exit, position_limit=position_limit,
                               retain_cost_when_rebalance=retain_cost_when_rebalance,
                               mae_mfe_window=mae_mfe_window, mae_mfe_window_step=mae_mfe_window_step)
 
     total_weight = position.abs().sum(axis=1)
 
-    position = position.div(total_weight.where(total_weight!=0, np.nan), axis=0).fillna(0)
-    position = position.clip(-abs(position_limit), abs(position_limit))
-
-    creturn = pd.Series(creturn_value, price.index)
-    creturn = creturn[(creturn != 1).cumsum().shift(-1, fill_value=1) != 0]
-    creturn = creturn.loc[:backtest_end_date]
-    if len(creturn) == 0:
-        creturn = pd.Series(1, position.index)
-
-    trades, operation_and_weight = get_trade_stocks(position.columns.astype(str).values, price.index.view(np.int64))
-    trades = pd.DataFrame(trades)
-    m = pd.DataFrame()
-
-    if len(trades) != 0:
-
-        trades.columns = ['stock_id', 'entry_date', 'exit_date',
-                     'entry_sig_date', 'exit_sig_date',
-                     'position', 'period', 'entry_index', 'exit_index']
-
-        trades.index.name = 'trade_index'
+    position = position.div(total_weight.where(total_weight!=0, np.nan), axis=0).fillna(0)\
+                       .clip(-abs(position_limit), abs(position_limit))
 
-        for col in ['entry_date', 'exit_date', 'entry_sig_date', 'exit_sig_date']:
-            trades[col] = pd.to_datetime(trades[col])
-            trades[col] = trades[col].dt.tz_localize(None)
-
-        trades.loc[trades.exit_index == -1, ['exit_date', 'exit_sig_date']] = pd.NaT
+    creturn = (pd.Series(creturn_value, price.index)
+                # remove the begining of creturn since there is no pct change
+                .pipe(lambda df: df[(df != 1).cumsum().shift(-1, fill_value=1) != 0])
+                # remove the tail of creturn for verification
+                .loc[:backtest_end_date]
+                # replace creturn to 1 if creturn is None
+                .pipe(lambda df: df if len(df) != 0 else pd.Series(1, position.index)))
+
+    trades, operation_and_weight = get_trade_stocks(position.columns.astype(str).values, 
+                                                    price.index.view(np.int64))
+
+    ####################################
+    # refine mae mfe dataframe
+    ####################################
+    def refine_mae_mfe():
+        if len(maemfe.mae_mfe) == 0:
+            return pd.DataFrame()
 
         m = pd.DataFrame(maemfe.mae_mfe)
         nsets = int((m.shape[1]-1) / 6)
 
         metrics = ['mae', 'gmfe', 'bmfe', 'mdd', 'pdays', 'return']
 
         tuples = sum([[(n, metric) if n == 'exit' else (n * mae_mfe_window_step, metric)
                        for metric in metrics] for n in list(range(nsets)) + ['exit']], [])
 
         m.columns = pd.MultiIndex.from_tuples(
             tuples, names=["window", "metric"])
         m.index.name = 'trade_index'
         m[m == -1] = np.nan
 
-        trades['return'] = m.iloc[:, -1]
+        exit = m.exit.copy()
 
-        if touched_exit:
-            trades['return'] = trades['return'].clip(-abs(stop_loss), abs(take_profit))
+        if touched_exit and len(m) > 0 and 'exit' in m.columns:
+            m['exit'] = (exit
+                .assign(gmfe=exit.gmfe.clip(-abs(stop_loss), abs(take_profit)))
+                .assign(bmfe=exit.bmfe.clip(-abs(stop_loss), abs(take_profit)))
+                .assign(mae=exit.mae.clip(-abs(stop_loss), abs(take_profit)))
+                .assign(mdd=exit.mdd.clip(-abs(stop_loss), abs(take_profit))))
+
+        return m
+    
+    m = refine_mae_mfe()
+
+    ####################################
+    # refine trades dataframe
+    ####################################
+    def convert_datetime_series(df):
+        cols = ['entry_date', 'exit_date', 'entry_sig_date', 'exit_sig_date']
+        df[cols] = df[cols].apply(lambda s: pd.to_datetime(s).dt.tz_localize(tz))
+        return df
+
+    def assign_exit_nat(df):
+        cols = ['exit_date', 'exit_sig_date']
+        df[cols] = df[cols].loc[df.exit_index != -1]
+        return df
+
+    trades = (pd.DataFrame(trades, 
+                           columns=['stock_id', 'entry_date', 'exit_date',
+                                    'entry_sig_date', 'exit_sig_date', 'position', 
+                                    'period', 'entry_index', 'exit_index'])
+              .rename_axis('trade_index')
+              .pipe(convert_datetime_series)
+              .pipe(assign_exit_nat)
+              .assign(**{'return': m.iloc[:, -1]})
+              )
+
+    if touched_exit:
+        trades['return'] = trades['return'].clip(-abs(stop_loss), abs(take_profit))
 
     r = report.Report(
         creturn=creturn,
         position=position,
         fee_ratio=fee_ratio,
         tax_ratio=tax_ratio,
         trade_at=trade_at_price,
@@ -374,63 +406,48 @@
         market_info=market)
 
     r.resample = resample
     r.stop_loss = stop_loss
     r.take_profit = take_profit
     r.live_performance_start = live_performance_start
 
-    if len(trades) != 0:
-        r.trades = trades
-        r.add_trade_info('trade_price', market.get_price(trade_at_price, adj=False), ['entry_date', 'exit_date'])
-
-    if len(m) != 0:
-        r.mae_mfe = m
+    r.mae_mfe = m
 
-        # clip max loss and profit to stop_loss and take_profit if touched_exit is on
-        if touched_exit and len(r.mae_mfe) > 0 and 'exit' in r.mae_mfe.columns:
-            exit = r.mae_mfe.exit.copy()
-            r.mae_mfe['exit'] = (exit
-                .assign(gmfe=exit.gmfe.clip(-abs(stop_loss), abs(take_profit)))
-                .assign(bmfe=exit.bmfe.clip(-abs(stop_loss), abs(take_profit)))
-                .assign(mae=exit.mae.clip(-abs(stop_loss), abs(take_profit)))
-                .assign(mdd=exit.mdd.clip(-abs(stop_loss), abs(take_profit))))
+    r.trades = trades
+    if len(r.trades) != 0:
+        r.add_trade_info('trade_price', market.get_price(trade_at_price, adj=False), ['entry_date', 'exit_date'])
 
+    r.actions = pd.Series(dtype=object)
     if len(operation_and_weight['actions']) != 0:
 
         # find selling and buying stocks
         actions = pd.Series(operation_and_weight['actions'])
         actions.index = r.position.columns[actions.index]
         r.actions = actions
 
         sell_sids = actions[actions == 'exit'].index
         buy_sids = actions[actions == 'enter'].index
 
         if len(trades):
-            r_position = set(trades.stock_id[trades.exit_sig_date.isnull()])
-
             # check if the sell stocks are in the current position
-            assert len(set(sell_sids) - r_position) == 0
+            assert len(set(sell_sids) - set(trades.stock_id[trades.exit_sig_date.isnull()])) == 0
 
             # fill exit_sig_date and exit_date
             trades.loc[trades.stock_id.isin(sell_sids), 'exit_sig_date'] = \
-                trades.loc[trades.stock_id.isin(sell_sids), 'exit_sig_date'].fillna(r.position.index[-1].tz_localize(None))
-            trades.loc[trades.stock_id.isin(sell_sids), 'exit_date'] = \
-                trades.loc[trades.stock_id.isin(sell_sids), 'exit_date']
+                trades.loc[trades.stock_id.isin(sell_sids), 'exit_sig_date'].fillna(r.position.index[-1])
 
-            final_trades = pd.concat([trades, pd.DataFrame({
+            r.trades = pd.concat([r.trades, pd.DataFrame({
               'stock_id': buy_sids,
               'entry_date': pd.NaT,
-              'entry_sig_date': r.position.index[-1].tz_localize(None),
+              'entry_sig_date': r.position.index[-1],
               'exit_date': pd.NaT,
               'exit_sig_date': pd.NaT,
             })], ignore_index=True)
 
-            r.trades = final_trades
-    else:
-        r.actions = pd.Series(dtype=object)
+            r.trades['exit_sig_date'] = pd.to_datetime(r.trades.exit_sig_date)
 
     # add mae mfe to report
     if hasattr(r, 'trades') and hasattr(r, 'mae_mfe'):
         trades = r.trades
         mae_mfe = r.mae_mfe
         exit_mae_mfe = mae_mfe['exit'].copy()
         exit_mae_mfe = exit_mae_mfe.drop(columns=['return'])
@@ -445,45 +462,45 @@
             | (r.trades.exit_sig_date == maxday)
             | (r.trades.entry_sig_date == latest_entry_day)
             | (r.trades.exit_sig_date.isnull())].set_index('stock_id')
 
     r.next_trading_date = max(r.current_trades.entry_sig_date.max(), r.current_trades.exit_sig_date.max())
 
     r.current_trades['weight'] = 0
+    r.weights = pd.Series(dtype='float64')
     if len(operation_and_weight['weights']) != 0:
         r.weights = pd.Series(operation_and_weight['weights'])
         r.weights.index = r.position.columns[r.weights.index]
         r.current_trades['weight'] = r.weights.reindex(r.current_trades.index).fillna(0)
 
     r.current_trades['next_weights'] = 0
+    r.next_weights = pd.Series(dtype='float64')
     if len(operation_and_weight['next_weights']) != 0:
         r.next_weights = pd.Series(operation_and_weight['next_weights'])
         r.next_weights.index = r.position.columns[r.next_weights.index]
 
         # normalize weight
         total_weight = r.next_weights.abs().sum()
 
         if total_weight > 1:
           r.next_weights /= total_weight
 
         r.current_trades['next_weights'] = r.next_weights.reindex(r.current_trades.index).fillna(0)
 
     # fill stock id to trade history
+    snames = market.get_asset_id_to_name()
     if len(trades) != 0:
-        snames = market.get_asset_id_to_name()
         r.trades['stock_id'] = r.trades.stock_id.map(lambda sid: f"{sid + ' ' + snames[sid] if sid in snames else sid}")
         r.current_trades.index = r.current_trades.index.map(lambda sid: f"{sid + ' ' + snames[sid] if sid in snames else sid}")
 
     if hasattr(r, 'actions') and len(r.actions) != 0:
-        snames = market.get_asset_id_to_name()
         r.actions.index = r.actions.index.map(lambda sid: f"{sid + ' ' + snames[sid] if sid in snames else sid}")
 
-    if hasattr(r, 'weights') and len(r.weights) != 0:
-        snames = market.get_asset_id_to_name()
-        r.weights.index = r.weights.index.map(lambda sid: f"{sid + ' ' + snames[sid] if sid in snames else sid}")
+    r.weights.index = r.weights.index.map(lambda sid: f"{sid + ' ' + snames[sid] if sid in snames else sid}")
+    r.next_weights.index = r.next_weights.index.map(lambda sid: f"{sid + ' ' + snames[sid] if sid in snames else sid}")
 
     set_global('backtest_report', r)
 
     if not upload:
         return r
 
     r.upload(name)
```

## finlab/data.py

```diff
@@ -4,16 +4,17 @@
 import json
 import pickle
 import logging
 import datetime
 import numpy as np
 import pandas as pd
 from io import BytesIO
+import finlab
 from finlab.utils import check_version, requests
-from finlab import login, get_token, dataframe
+from finlab.market_info import TWMarketInfo, MarketInfo
 
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger(__name__)
 
 
 class CacheStorage():
 
@@ -34,46 +35,49 @@
               ``` py
               close = data._storage._cache['price:收盤價']
               ```
         """
 
         self._cache = {}
         self._cache_time = {}
+        self._cache_expiry = {}
         self._stock_names = {}
 
     @staticmethod
-    def expired(cache_time):
+    def now():
+        return datetime.datetime.now(tz=datetime.timezone.utc)
 
-        now = datetime.datetime.now(datetime.timezone.utc)
-        pm7 = datetime.datetime(now.year, now.month,
-                                now.day, hour=11, tzinfo=datetime.timezone.utc)
+    def set_dataframe(self, name, df, expiry=None):
+        self._cache[name] = df
+        self._cache_time[name] = self.now()
+        self._cache_expiry[name] = expiry or self.now()
 
-        if now > pm7 and cache_time < pm7:
-            return True
-        if now - cache_time > datetime.timedelta(hours=12):
-            return True
-        return False
+    def set_stock_names(self, stock_names):
+        self._stock_names = {**self._stock_names, **stock_names}
 
-    def exists(self, name):
+    def get_time_created(self, name):
 
-        now = datetime.datetime.now(datetime.timezone.utc)
+        if name not in self._cache or name not in self._cache_time:
+            return None
 
-        if (name in self._cache) and not self.expired(self._cache_time[name]):
-            return True
-        return False
+        return self._cache_time[name]
 
-    def set_dataframe(self, name, df):
-        now = datetime.datetime.now(datetime.timezone.utc)
-        self._cache[name] = df
-        self._cache_time[name] = now
+    def get_time_expired(self, name):
 
-    def set_stock_names(self, stock_names):
-        self._stock_names = {**self._stock_names, **stock_names}
+        if name in self._cache_expiry:
+            return self._cache_expiry[name]
+
+        return None
 
     def get_dataframe(self, name):
+
+        # not exists
+        if name not in self._cache or name not in self._cache_time:
+            return None
+
         return self._cache[name]
 
     def get_stock_names(self):
         return self._stock_names
 
 
 class FileStorage():
@@ -95,72 +99,89 @@
               import pickle
               close = pickle.load(open('finlab_db/price:收盤價.pickle', 'rb'))
               ```
         """
         self._path = path
         self._cache = {}
         self._stock_names = None
+        self._expiry = {}
 
         if not os.path.isdir(path):
             os.mkdir(path)
 
         f_stock_names = os.path.join(path, 'stock_names.pkl')
 
         if not os.path.isfile(f_stock_names):
             with open(f_stock_names, 'wb') as f:
                 pickle.dump({}, f)
         else:
             with open(f_stock_names, 'rb') as f:
                 self._stock_names = pickle.load(f)
 
-    def set_dataframe(self, name, df):
+        f_expiry = os.path.join(self._path, 'expiry.pkl')
+
+        if not os.path.isfile(f_expiry):
+            with open(f_expiry, 'wb') as f:
+                pickle.dump({}, f)
+        else:
+            with open(f_expiry, 'rb') as f:
+                self._expiry = pickle.load(f)
+
+    def set_dataframe(self, name, df, expiry=None):
         file_path = os.path.join(
             self._path, name + '.pickle').replace(':', '#')
         df.to_pickle(file_path)
         self._cache[name] = df
+        self._expiry[name] = expiry or CacheStorage.now()
+
+        with open(os.path.join(self._path, 'expiry.pkl'), 'wb') as f:
+            pickle.dump(self._expiry, f)
+
+    def get_time_created(self, name):
+
+        # check existence
+        file_path = os.path.join(
+            self._path, name + '.pickle').replace(':', '#')
+
+        if not os.path.isfile(file_path):
+            return None
+
+        return datetime.datetime.fromtimestamp(
+            os.path.getmtime(file_path), tz=datetime.timezone.utc)
+
+    def get_time_expired(self, name):
+
+        if name in self._expiry:
+            return self._expiry[name]
+
+        return None
 
     def get_dataframe(self, name):
 
         if name in self._cache:
             return self._cache[name]
 
         file_path = os.path.join(
             self._path, name + '.pickle').replace(':', '#')
+
         if os.path.isfile(file_path):
             ret = pd.read_pickle(file_path)
             self._cache[name] = ret
             return ret
-        return None
-
-    def exists(self, name):
-
-        file_path = os.path.join(
-            self._path, name + '.pickle').replace(':', '#')
-
-        if not os.path.isfile(file_path):
-            return False
-
-        modify_time = datetime.datetime.fromtimestamp(
-            os.path.getmtime(file_path), tz=datetime.timezone.utc)
-
-        if CacheStorage.expired(modify_time):
-            return False
 
-        return True
+        return None
 
     def set_stock_names(self, stock_names):
-        with open(os.path.join(self._path, 'stock_names.pkl'), 'rb') as f:
-            stock_names_ = pickle.load(f)
-        stock_names_ = {**stock_names, **stock_names}
+        self._stock_names = {**self._stock_names, **stock_names}
 
         with open(os.path.join(self._path, 'stock_names.pkl'), 'wb') as f:
-            pickle.dump(stock_names_, f)
-        self._stock_names = stock_names_
+            pickle.dump(self._stock_names, f)
 
     def get_stock_names(self):
+
         if self._stock_names is not None:
             return self._stock_names
 
         with open(os.path.join(self._path, 'stock_names.pkl'), 'rb') as f:
             stock_names = pickle.load(f)
         self._stock_names = stock_names
         return stock_names
@@ -203,15 +224,15 @@
 
 
 class universe():
     def __init__(self, market='ALL', category='ALL'):
         """當呼叫 `data.get` 或是 `data.indicator` 時，返回產業相關類股。
 
         Args:
-            market (str): Universe market type. ex: `ALL`, `TSE`, `OTC`, `TSE_OTC`, `ETF`
+            market (str): Universe market type. ex: `ALL`, `TSE`, `OTC`, `TSE_OTC`, `ETF`, `STOCK_FUTURE`
             category (str): Stock categories, can be either a string or a list. ex: `光電業`, `其他`, `其他電子業`, `化學工業`, `半導體`, `塑膠工業`, `存託憑證`, `建材營造`, `文化創意業`, `橡膠工業`, `水泥工業`,`汽車工業`, `油電燃氣業`, `玻璃陶瓷`, `生技醫療`, `生技醫療業`, `紡織纖維`, `航運業`, `觀光事業`, `貿易百貨`, `資訊服務業`, `農業科技`, `通信網路業`, `造紙工業`, `金融`, `鋼鐵工業`, `電器電纜`, `電子商務`, `電子通路業`, `電子零組件`, `電機機械`, `電腦及週邊`, `食品工業`
 
         Examples:
 
             想要當鋼鐵人、航海王，可以用以下方法將這些類股一次選出來
             ``` py
             with universe('TSE_OTC', ['鋼鐵工業', '航運業']):
@@ -243,15 +264,15 @@
         universe_stocks = self._previous_stocks
 
 
 def set_universe(market: str = 'ALL', category='ALL'):
     """Set subset of stock ids when retrieve data using data.get or data.indicator
 
     Args:
-        market (str): universe market type. ex: 'ALL', 'TSE', 'OTC', 'TSE_OTC', 'ETF'
+        market (str): universe market type. ex: 'ALL', 'TSE', 'OTC', 'TSE_OTC', 'ETF', 'STOCK_FUTURE'
         category (str): stock categories, can be either a string or a list. ex: '光電業', '其他', '其他電子業',
    '化學工業', '半導體', '塑膠工業', '存託憑證', '建材營造', '文化創意業', '橡膠工業', '水泥工業',
    '汽車工業', '油電燃氣業', '玻璃陶瓷', '生技醫療', '生技醫療業', '紡織纖維', '航運業', '觀光事業', '貿易百貨',
    '資訊服務業', '農業科技', '通信網路業', '造紙工業', '金融', '鋼鐵工業', '電器電纜', '電子商務',
    '電子通路業', '電子零組件', '電機機械', '電腦及週邊', '食品工業'
 
 
@@ -268,14 +289,19 @@
     elif market == 'OTC':
         market_match = categories.market == 'otc'
     elif market == 'TSE_OTC':
         market_match = (categories.market == 'sii') | (
             categories.market == 'otc')
     elif market == 'ETF':
         market_match = categories.market == 'other_securities'
+    elif market == 'STOCK_FUTURE':
+        futures_and_options = get('single_stock_futures_and_equity_options_underlying')
+        futures_and_options = futures_and_options[~futures_and_options['stock_id'].duplicated()]
+        futures_and_options = categories.merge(futures_and_options, how='left', on='stock_id')
+        market_match = futures_and_options['是否為股票期貨標的'] == 'Y'
 
     category_match = pd.Series(True, categories.index)
 
     if category == 'ALL':
         pass
     else:
         if isinstance(category, str):
@@ -288,15 +314,15 @@
                 set([c for c in all_categories if isinstance(c, str) and re.search(ca, c)]))
         category_match = categories.category.isin(matched_categories)
 
     global universe_stocks
     universe_stocks = set(categories.stock_id[market_match & category_match])
 
 
-def get(dataset: str, save_to_storage: bool = True):
+def get(dataset: str, save_to_storage: bool = True, force_download=False):
     """下載歷史資料
 
     請至[歷史資料目錄](https://ai.finlab.tw/database) 來獲得所有歷史資料的名稱，即可使用此函式來獲取歷史資料。
     假設 `save_to_storage` 為 `True` 則，程式會自動在本地複製一份，以避免重複下載大量數據。
 
     Args:
         dataset (str): The name of dataset.
@@ -325,62 +351,76 @@
 
     """
     check_version()
 
     global universe_stocks
     global _storage
 
-    not_available_universe_stocks = ['benchmark_return', 'institutional_investors_trading_all_market_summary',
-                                     'margin_balance', 'intraday_trading_stat',
-                                     'stock_index_price', 'stock_index_vol',
-                                     'taiex_total_index', 'broker_info',
-                                     'rotc_monthly_revenue', 'rotc_price',
-                                     'world_index', 'rotc_broker_trade_record',
-                                     'us_price', 'us_sp500',
-                                     'us_tickers', 'security_categories',
-                                     ]
-
-    # use cache if possible
-    if _storage.exists(dataset):
-        ret = _storage.get_dataframe(dataset)
+    not_available_universe_stocks = [
+        'benchmark_return', 'institutional_investors_trading_all_market_summary',
+        'margin_balance', 'intraday_trading_stat',
+        'stock_index_price', 'stock_index_vol',
+        'taiex_total_index', 'broker_info',
+        'rotc_monthly_revenue', 'rotc_price',
+        'world_index', 'rotc_broker_trade_record',
+        'us_price', 'us_sp500',
+        'us_tickers', 'security_categories',
+        ]
+
+    def refine_stock_id(ret):
+
         if dataset.split(':')[0] in not_available_universe_stocks:
             return ret
         if ':' in dataset:
             return ret if not universe_stocks else ret[ret.columns.intersection(universe_stocks)]
-        else:
-            if 'stock_id' in ret.columns:
-                return ret if not universe_stocks else ret[ret['stock_id'].isin(universe_stocks)]
-            else:
-                return ret
+        if 'stock_id' in ret.columns:
+            return ret if not universe_stocks else ret.loc[ret['stock_id'].isin(universe_stocks)]
 
-    api_token = get_token()
+        return ret
+
+    # not expired
+    time_expired = _storage.get_time_expired(dataset)
+    if time_expired and time_expired > CacheStorage.now() and not force_download:
+        return refine_stock_id(_storage.get_dataframe(dataset))
 
     # request for auth url
-    request_args = {
-        'api_token': api_token,
+    url = 'https://asia-east2-fdata-299302.cloudfunctions.net/auth_generate_data_url'
+    params = {
+        'api_token': finlab.get_token(),
         'bucket_name': 'finlab_tw_stock_item',
         'blob_name': dataset.replace(':', '#') + '.feather'
     }
 
-    url = 'https://asia-east2-fdata-299302.cloudfunctions.net/auth_generate_data_url_limit_test'
-    res = requests.post(url, request_args)
-    url_data = res.json()
+    time_saved = _storage.get_time_created(dataset)
+    if time_saved and not force_download:
+        params['time_saved'] = time_saved.strftime('%Y%m%d%H%M%S')
+
+    res = requests.post(url, params)
+
+    try:
+        url_data = res.json()
+    except:
+        raise Exception("Cannot get response from data server.")
+
+    # use cache
+    if 'url' in url_data and url_data['url'] == '':
+        return refine_stock_id(_storage.get_dataframe(dataset))
 
     if 'quota' in url_data:
         logger.warning(
             f'{dataset} -- Daily data usage: {url_data["quota"]:.1f} / {url_data["limit_size"]} MB')
 
     if 'error' in url_data:
 
         if url_data['error'] in [
             'request not valid',
             'User not found',
             'api_token not valid',
                 'api_token not match', ]:
-            login()
+            finlab.login()
             return get(dataset, save_to_storage)
 
         raise Exception(f"**Error: {url_data['error']}")
 
     assert 'url' in url_data
 
     res = requests.get(url_data['url'])
@@ -407,47 +447,55 @@
             check_numeric_dtype = pd.api.types.is_numeric_dtype(df.values)
             if check_numeric_dtype:
                 df = df.transpose().groupby(level=0).mean().transpose()
             else:
                 df = df.fillna(np.nan).transpose().groupby(
                     level=0).last().transpose()
 
-        df = dataframe.FinlabDataFrame(df)
+        df = finlab.dataframe.FinlabDataFrame(df)
 
-        if table_name in ['monthly_revenue', 'rotc_monthly_revenue']:
+        if table_name in ['monthly_revenue', 'rotc_monthly_revenue',
+                          'monthly_revenue@Deadline', 'rotc_monthly_revenue@Deadline']:
             df = df._index_date_to_str_month()
-        elif table_name in ['financial_statement', 'fundamental_features']:
+        elif table_name in ['financial_statement', 'fundamental_features',
+                            'financial_statement@Deadline', 'fundamental_features@Deadline']:
             df = df._index_date_to_str_season()
-
+        elif table_name in ['us_fundamental']:
+            df = df._index_date_to_str_season('-US')
     # save cache
     if save_to_storage:
-        _storage.set_dataframe(dataset, df)
+        expiry = datetime.datetime.strptime(
+                url_data['time_scheduled'], '%Y%m%d%H%M%S').replace(tzinfo=datetime.timezone.utc)\
+                if 'time_scheduled' in url_data else None
 
-    if dataset.split(':')[0] in not_available_universe_stocks:
-        return df
+        _storage.set_dataframe(dataset, df, expiry=expiry)
 
-    if ':' in dataset:
-        return df if not universe_stocks else df[df.columns.intersection(universe_stocks)]
+    return refine_stock_id(df)
 
-    if 'stock_id' in df.columns:
-        return df if not universe_stocks else df[df['stock_id'].isin(universe_stocks)]
 
-    return df
+def get_input_args(attr):
+    input_names = attr.input_names
+    refine_input_names = []
+    for key, val in input_names.items():
+        if 'price' in key:
+            if isinstance(val, list):
+                refine_input_names += val
+            elif isinstance(val, str):
+                refine_input_names.append(val)
 
+    return refine_input_names
 
-def indicator(indname, adjust_price=False, resample='D', **kwargs):
+def indicator(indname, adjust_price=False, resample='D', market:MarketInfo=TWMarketInfo(), **kwargs):
     """支援 Talib 和 pandas_ta 上百種技術指標，計算 2000 檔股票、10年的所有資訊。
 
     在使用這個函式前，需要安裝計算技術指標的 Packages
 
     * [Ta-Lib](https://github.com/mrjbq7/ta-lib)
     * [Pandas-ta](https://github.com/twopirllc/pandas-ta)
 
-    則一使用即可。
-
     Args:
         indname (str): 指標名稱，
             以 TA-Lib 舉例，例如 SMA, STOCH, RSI 等，可以參考 [talib 文件](https://mrjbq7.github.io/ta-lib/doc_index.html)。
 
             以 Pandas-ta 舉例，例如 supertrend, ssf 等，可以參考 [Pandas-ta 文件](https://twopirllc.github.io/pandas-ta/#indicators-by-category)。
         adjust_price (bool): 是否使用還原股價計算。
         resample (str): 技術指標價格週期，ex: `D` 代表日線, `W` 代表週線, `M` 代表月線。
@@ -468,26 +516,19 @@
             getattr(pd.DataFrame().ta, indname)
             attr = lambda df, **kwargs: getattr(df.ta, indname)(**kwargs)
             package = 'pandas_ta'
         except:
             raise Exception(
                 "Please install TA-Lib or pandas_ta to get indicators.")
 
-    if adjust_price:
-        close = get('etl:adj_close')
-        open_ = get('etl:adj_open')
-        high = get('etl:adj_high')
-        low = get('etl:adj_low')
-        volume = get('price:成交股數')
-    else:
-        close = get('price:收盤價')
-        open_ = get('price:開盤價')
-        high = get('price:最高價')
-        low = get('price:最低價')
-        volume = get('price:成交股數')
+    close = market.get_price('close', adj=adjust_price)
+    open_ = market.get_price('open', adj=adjust_price)
+    high = market.get_price('high', adj=adjust_price)
+    low = market.get_price('low', adj=adjust_price)
+    volume = market.get_price('volume', adj=adjust_price)
 
     if resample.upper() != 'D':
         close = close.resample(resample).last()
         open_ = open_.resample(resample).first()
         high = high.resample(resample).max()
         low = low.resample(resample).min()
         volume = volume.resample(resample).sum()
@@ -504,19 +545,23 @@
 
         if package == 'pandas_ta':
             prices = pd.DataFrame(prices)
             s = attr(prices, **kwargs)
 
         elif package == 'talib':
             abstract_input = list(attr.input_names.values())[0]
+            abstract_input = get_input_args(attr)
 
             # quick fix talib bug
             if indname == 'OBV':
                 abstract_input = ['close', 'volume']
 
+            if indname == 'BETA':
+                abstract_input = ['high', 'low']
+
             if isinstance(abstract_input, str):
                 abstract_input = [abstract_input]
             paras = [prices[k] for k in abstract_input]
             s = attr(*paras, **kwargs)
         else:
             raise Exception("Cannot determine technical package from indname")
 
@@ -545,17 +590,17 @@
     for key, df in dfs.items():
         newdic[key] = pd.DataFrame(df, index=close.index)
 
     ret = [newdic[n] for n in default_output_columns]
     ret = [d.apply(lambda s:pd.to_numeric(s, errors='coerce')) for d in ret]
 
     if len(ret) == 1:
-        return dataframe.FinlabDataFrame(ret[0])
+        return finlab.dataframe.FinlabDataFrame(ret[0])
 
-    return tuple([dataframe.FinlabDataFrame(df) for df in ret])
+    return tuple([finlab.dataframe.FinlabDataFrame(df) for df in ret])
 
 
 def get_strategies(api_token=None):
     """取得已上傳量化平台的策略回傳資料。
 
     可取得自己策略儀表板上的數據，例如每個策略的報酬率曲線、報酬率統計、夏普率、近期部位、近期換股日...，
     這些數據可以用來進行多策略彙整的應用喔！
@@ -657,15 +702,15 @@
             'update_date': '2022-06-10'
             },
           strategy2:{...},
           ...}
         ```
     """
     if api_token is None:
-        api_token = get_token()
+        api_token = finlab.get_token()
 
     request_args = {
         'api_token': api_token,
     }
 
     url = 'https://asia-east2-fdata-299302.cloudfunctions.net/auth_get_strategies'
     response = requests.get(url, request_args)
@@ -676,7 +721,73 @@
         return {}
     try:
         return json.loads(response.text)
     except:
         pass
 
     return response.text
+
+
+def search(keyword=None, display_info=['name', 'description', 'type']):
+    """查詢與取得資料庫目錄資訊。
+
+    查詢FinLab資料庫目錄中的資料表名稱或項目欄位名稱是否包含關鍵字，方便搜尋資料庫是否存在目標資料。
+
+    Args:
+        keyword (str): 欲查詢關鍵字。
+        display_info (list):指定顯示的資訊項目，預設只顯示「資料表英文代稱、資料表的中文描述、資料表欄位名稱」，若設定為None，則顯示全部資訊。
+
+    Returns:
+        (list): database information
+
+    Response detail:
+        ``` py
+        [{'name': 'financial_statement',
+          'description': '財報',
+          'type': {'存貨': 'float-資產負債表(仟元)', '存貨_增加_減少': 'float-單季現金流量表(仟元)'}},
+         {'name': 'fundamental_features',
+          'description': '財務指標',
+          'type': {'存貨週轉率': 'float-(%)'}},
+         {'name': 'tw_total_pmi',
+          'description': '台灣製造業採購經理人指數',
+          'type': {'存貨': 'float', '客戶存貨': 'float'}},...]
+
+        ```
+    Examples:
+
+        ``` py
+
+        # 查詢各資料表的欄位名稱含有'存貨'關鍵字的相關資料表資訊
+        ex1 = search_database_category(keyword='存貨')
+        # 取得資料庫所有資訊
+        ex2 = search_database_category(display_info=None)
+        ```
+    """
+    if not hasattr(search, 'db_info'):
+        res = requests.get('https://asia-east2-fdata-299302.cloudfunctions.net/get_data_info')
+        search.db_info = json.loads(res.text)['data']
+
+    db_info = search.db_info
+
+    if display_info:
+        db_info = [{i: table[i] for i in display_info} for table in db_info]
+
+    result = []
+    if keyword:
+        result = [table for table in db_info if (re.search(keyword, table['description'], re.IGNORECASE)) or (
+            re.search(keyword, table['name'], re.IGNORECASE))]
+        result_tables = [table['name'] for table in result]
+
+    def check_column_contains_keyword(table, keyword):
+        table = table.copy()
+        keyword_exist = {k: v for k, v in table['type'].items() if re.search(keyword, k, re.IGNORECASE)}
+        if len(keyword_exist) > 0:
+            table['type'] = keyword_exist
+            return table
+
+    if keyword:
+        for table in db_info:
+            if table['name'] not in result_tables:
+                checked_table = check_column_contains_keyword(table, keyword=keyword)
+            if checked_table is not None:
+                result.append(checked_table)
+    return result
```

## finlab/dataframe.py

```diff
@@ -1,12 +1,16 @@
 from finlab.utils import logger
 import datetime
 import numpy as np
 import pandas as pd
 from finlab import data
+import functools
+
+monthly_index = None
+
 
 class FinlabDataFrame(pd.DataFrame):
     """回測語法糖
     除了使用熟悉的 Pandas 語法外，我們也提供很多語法糖，讓大家開發程式時，可以用簡易的語法完成複雜的功能，讓開發策略更簡潔！
     我們將所有的語法糖包裹在 `FinlabDataFrame` 中，用起來跟 `pd.DataFrame` 一樣，但是多了很多功能！
     只要使用 `finlab.data.get()` 所獲得的資料，皆為 `FinlabDataFrame` 格式，
     接下來我們就來看看， `FinlabDataFrame` 有哪些好用的語法糖吧！
@@ -27,14 +31,18 @@
     cond1 = close > 37
     cond2 = roa > 0
     cond_1_2 = cond1 & cond2
     ```
     擷取 1101 台泥 的訊號如下圖，可以看到 `cond1` 跟 `cond2` 訊號的頻率雖然不相同，但是由於 `cond1` 跟 `cond2` 是 `FinlabDataFrame`，所以可以直接取交集，而不用處理資料頻率對齊的問題。
     <br />
     <img src="https://i.ibb.co/m9chXSQ/imageconds.png" alt="imageconds">
+
+    總結來說，FinlabDataFrame 與一般 dataframe 唯二不同之處：
+    1. 多了一些 method，如`df.is_largest()`, `df.sustain()`...等。
+    2. 在做四則運算、不等式運算前，會將 df1、df2 的 index 取聯集，column 取交集。
     """
 
     @property
     def _constructor(self):
         return FinlabDataFrame
 
     @staticmethod
@@ -123,14 +131,18 @@
         df1, df2 = self.reshape(self, other)
         return pd.DataFrame.__and__(df1, df2)
 
     def __or__(self, other):
         df1, df2 = self.reshape(self, other)
         return pd.DataFrame.__or__(df1, df2)
 
+    def __getitem__(self, other):
+        df1, df2 = self.reshape(self, other)
+        return pd.DataFrame.__getitem__(df1, df2)
+
     def index_str_to_date(self):
       """財務月季報索引格式轉換
 
         將以下資料的索引轉換成datetime格式:
 
         月營收 (ex:2022-M1) 從文字格式轉為公告截止日。
 
@@ -149,22 +161,32 @@
       """
       if len(self.index) == 0 or not isinstance(self.index[0], str):
         return self
 
       if self.index[0].find('M') != -1:
         return self._index_str_to_date_month()
       elif self.index[0].find('Q') != -1:
-        return self._index_str_to_date_season()
+        if self.index[0].find('US') != -1:
+          return self._index_str_to_date_season(us=True)
+        else:
+          return self._index_str_to_date_season()
 
       return self
 
     @staticmethod
     def to_business_day(date):
+
+        def skip_weekend(d):
+            add_days = {5: 2, 6: 1}
+            wd = d.weekday()
+            if wd in add_days: d += datetime.timedelta(days=add_days[wd])
+            return d
+
         close = data.get('price:收盤價')
-        return pd.Series(date).apply(lambda d: d if d in close.index or d < close.index[0] or d > close.index[-1] else close.loc[d:].index[0]).values
+        return pd.Series(date).apply(lambda d: skip_weekend(d) if d in close.index or d < close.index[0] or d > close.index[-1] else close.loc[d:].index[0]).values
 
     def get_index_str_frequency(self):
 
         if len(self.index) == 0:
           return None
 
         if not isinstance(self.index[0], str):
@@ -176,58 +198,62 @@
         if (self.index.str.find('Q') != -1).all():
           return 'season'
 
         return None
 
     def _index_date_to_str_month(self):
 
+        if isinstance(self.index[0], pd.Timestamp):
+            global monthly_index
+            monthly_index = self.index
+
         # index is already str
         if len(self.index) == 0 or not isinstance(self.index[0], pd.Timestamp):
-          return self
+            return self
 
         index = (self.index - datetime.timedelta(days=30)).strftime('%Y-M%m')
-        return FinlabDataFrame(self.values, index=index, columns=self.columns)
+        df = FinlabDataFrame(self.values, index=index, columns=self.columns)
+
+        return df
 
     def _index_str_to_date_month(self):
 
         # index is already timestamps
         if len(self.index) == 0 or not isinstance(self.index[0], str):
           return self
 
+        global monthly_index
+
+        if monthly_index is None:
+            rev = data.get('monthly_revenue:當月營收', force_download=True)
+
         if not (self.index.str.find('M') != -1).all():
           logger.warning('FinlabDataFrame: invalid index, cannot format index to monthly timestamp.')
           return self
 
-        index = pd.to_datetime(self.index, format='%Y-M%m') + pd.offsets.MonthBegin() + datetime.timedelta(days=9)
-        # chinese new year and covid-19 impact monthly revenue deadline
-        replacements = {
-                        datetime.datetime(2020, 2, 10): datetime.datetime(2020, 2, 15),
-                        datetime.datetime(2021, 2, 10): datetime.datetime(2021, 2, 15),
-                        datetime.datetime(2022, 2, 10): datetime.datetime(2022, 2, 14),
-                        }
-        replacer = replacements.get
-        index = [replacer(n, n) for n in index]
-
+        index = monthly_index
         index = self.to_business_day(index)
 
         ret = FinlabDataFrame(self.values, index=index, columns=self.columns)
         ret.index.name = 'date'
+ 
         return ret
-
-    def _index_date_to_str_season(self):
+    def _index_date_to_str_season(self, postfix=''):
 
         # index is already str
         if len(self.index) == 0 or not isinstance(self.index[0], pd.Timestamp):
           return self
-
-        q = self.index.strftime('%m').astype(int).map({5:1, 8:2, 9:2, 10:3, 11:3, 3:4, 4:4})
+          
         year = self.index.year.copy()
-        year -= (q == 4)
-        index = year.astype(str) + '-Q' + q.astype(str)
-
+        if postfix:
+          q = self.index.strftime('%m').astype(int).map({3:1, 6:2, 9:3, 12:4})
+        else:
+          q = self.index.strftime('%m').astype(int).map({5:1, 8:2, 9:2, 10:3, 11:3, 3:4, 4:4})
+          year -= (q == 4)
+        index = year.astype(str) + f'{postfix}-Q' + q.astype(str)
         return FinlabDataFrame(self.values, index=index, columns=self.columns)
 
     def deadline(self):
         """財務季報索引轉換成公告截止日
 
           將財務季報 (ex:2022Q1) 從文字格式轉為公告截止日的datetime格式，
           通常使用情境為對不同週期的dataframe做reindex，常用於以公告截止日作為訊號產生日。
@@ -236,118 +262,40 @@
           Examples:
               ```py
               data.get('financial_statement:現金及約當現金').deadline()
               ```
         """
         return self._index_str_to_date_season(detail=False)
 
-    def _index_str_to_date_season(self, detail=True):
+    def _index_str_to_date_season(self, detail=True, us=False):
+      datekey = data.get('us_fundamental:datekey').copy() if us else calc_disclosure_dates(detail)
+      disclosure_dates = (datekey
+                          .reindex_like(self)
+                          .unstack())
 
-      disclosure_dates = self.calc_disclosure_dates(detail)
-      disclosure_dates = disclosure_dates.reindex_like(self).unstack()
       self.columns.name = 'stock_id'
 
       unstacked = self.unstack()
 
-      df = pd.DataFrame({
-        'value': unstacked.values,
-        'disclosures': disclosure_dates.values,
-      }, unstacked.index).reset_index()
-
-      ret = df.drop_duplicates(['disclosures', 'stock_id']).pivot('disclosures', 'stock_id')['value'].ffill()
-      ret = FinlabDataFrame(ret)
-      ret.index.name = 'date'
+      ret = (pd.DataFrame({
+          'value': unstacked.values,
+          'disclosures': disclosure_dates.values,
+        }, unstacked.index)
+        .reset_index()
+        .drop_duplicates(['disclosures', 'stock_id'])
+        .pivot(index='disclosures', columns='stock_id', values='value').ffill()
+        .pipe(lambda df: df.loc[df.index.notna()])
+        .pipe(lambda df: FinlabDataFrame(df))
+        .rename_axis('date')
+      )
 
       if not detail:
           ret.index = self.to_business_day(ret.index)
-      return ret
-
-    def calc_disclosure_dates(self, detail=True):
-
-      cinfo = data.get('company_basic_info').copy()
-      cinfo['id'] = cinfo.stock_id.str.split(' ').str[0]
-      cinfo = cinfo.set_index('id')
-      cinfo = cinfo[~cinfo.index.duplicated(keep='last')]
-
-      def calc_default_disclosure_dates(s):
-        sid = s.name
-        cat = cinfo.loc[sid].產業類別 if sid in cinfo.index else 'etf'
-        short_name = cinfo.loc[sid].公司簡稱 if sid in cinfo.index else 'etf'
-
-        if cat == '金融業':
-          calendar = {
-            '1': '-05-15',
-            '2': '-08-31',
-            '3': '-11-14',
-            '4': '-03-31',
-          }
-        elif cat == '金融保險業':
-          calendar = {
-            '1': '-04-30',
-            '2': '-08-31',
-            '3': '-10-31',
-            '4': '-03-31',
-          }
-        elif 'KY' in short_name:
-            calendar = {
-            'old':{
-                '1': '-05-15',
-                '2': '-08-14',
-                '3': '-11-14',
-                '4': '-03-31',
-                 },
-            'new':{
-                '1': '-05-15',
-                '2': '-08-31',
-                '3': '-11-14',
-                '4': '-03-31',
-                 },
-            }
-        else:
-          calendar = {
-            '1': '-05-15',
-            '2': '-08-14',
-            '3': '-11-14',
-            '4': '-03-31',
-          }
-        get_year = lambda year, season: str(year) if int(season) != 4 else str(int(year) + 1)
-        ky_policy_check = lambda year: 'new' if year >= '2021' else 'old'
-        return pd.to_datetime(s.index.map(lambda d: get_year(d[:4], d[-1]) + calendar[ky_policy_check(d[:4])][d[-1]]) if 'KY' in short_name else s.index.map(lambda d: get_year(d[:4], d[-1]) + calendar[d[-1]]))
-
-      def season_end(s):
 
-        calendar = {
-          '1': '-3-31',
-          '2': '-6-30',
-          '3': '-9-30',
-          '4': '-12-31',
-        }
-        return pd.to_datetime(s.index.map(lambda d: d[:4] + calendar[d[-1]]))
-
-
-      disclosure_dates = data.get('financial_statements_upload_detail:upload_date')
-      disclosure_dates = disclosure_dates.apply(pd.to_datetime)
-      disclosure_dates = disclosure_dates.reindex_like(self)
-
-      financial_season_end = disclosure_dates.apply(season_end)
-      default_disclosure_dates = disclosure_dates.apply(calc_default_disclosure_dates)
-
-      disclosure_dates[(disclosure_dates > default_disclosure_dates)
-                       | (disclosure_dates < financial_season_end)] = pd.NaT
-      disclosure_dates[(disclosure_dates.diff() <= datetime.timedelta(days=0))] = pd.NaT
-      disclosure_dates.loc['2019-Q1', '3167'] = pd.NaT
-      disclosure_dates.loc['2015-Q1', '5536'] = pd.NaT
-      disclosure_dates.loc['2018-Q1', '5876'] = pd.NaT
-
-      disclosure_dates = disclosure_dates.fillna(default_disclosure_dates)
-      disclosure_dates.columns.name = 'stock_id'
-
-      if detail:
-        return disclosure_dates
-      return default_disclosure_dates
+      return ret
 
     def average(self, n):
         """取 n 筆移動平均
 
         若股票在時間窗格內，有 N/2 筆 NaN，則會產生 NaN。
         Args:
           n (positive-int): 設定移動窗格數。
@@ -390,15 +338,15 @@
             ```py
             from finlab import data
 
             roa = data.get('fundamental_features:ROA稅後息前')
             good_stocks = roa.is_largest(10)
             ```
         """
-        return self.apply(lambda s: s.nlargest(n), axis=1).reindex_like(self).notna()
+        return self.astype(float).apply(lambda s: s.nlargest(n), axis=1).reindex_like(self).notna()
 
     def is_smallest(self, n):
         """取每列前 n 筆小的數值
 
         若符合 `True` ，反之為 `False` 。用來篩選每天數值最小的股票。
         Args:
           n (positive-int): 設定每列前 n 筆小的數值。
@@ -409,15 +357,15 @@
             ```py
             from finlab import data
 
             pb = data.get('price_earning_ratio:股價淨值比')
             cheap_stocks = pb.is_smallest(10)
             ```
         """
-        return self.apply(lambda s: s.nsmallest(n), axis=1).notna()
+        return self.astype(float).apply(lambda s: s.nsmallest(n), axis=1).reindex_like(self).notna()
 
     def is_entry(self):
         """進場點
 
         取進場訊號點，若符合條件的值則為True，反之為False。
         Returns:
           (pd.DataFrame): data
@@ -550,14 +498,46 @@
             from finlab import data
             data.get('price:收盤價').rise().sustain(2)
             ```
         """
         nsatisfy = nsatisfy or nwindow
         return self.rolling(nwindow).sum() >= nsatisfy
 
+    def industry_rank(self, categories=None):
+        """計算產業 ranking 排名，0 代表產業內最低，1 代表產業內最高
+        Args:
+          categories (list of str): 欲考慮的產業，ex: ['貿易百貨', '雲端運算']，預設為全產業，請參考 `data.get('security_industry_themes')` 中的產業項目。
+        Examples:
+            本意比產業排名分數
+            ```py
+            from finlab import data
+
+            pe = data.get('price_earning_ratio:本益比')
+            pe_rank = pe.industry_rank()
+            print(pe_rank)
+            ```
+        """
+
+        themes = (data.get('security_industry_themes')
+            .copy() # 複製
+            .assign(category=lambda self: self.category
+                .apply(lambda s: eval(s))) # 從文字格式轉成陣列格
+            .explode('category') # 展開資料
+        )
+
+        categories = (categories 
+            or set(themes.category[themes.category.str.find(':') == -1]))
+
+        def calc_rank(ind):
+            stock_ids = themes.stock_id[themes.category == ind]
+            return (self[stock_ids].pipe(lambda self: self.rank(axis=1, pct=True)))
+
+        return (pd.concat([calc_rank(ind) for ind in categories],axis=1)
+            .groupby(level=0, axis=1).mean())
+
     def quantile_row(self, c):
         """股票當天數值分位數
 
         取得每列c定分位數的值。
         Args:
           c (positive-int): 設定每列 n 定分位數的值。
         Returns:
@@ -715,7 +695,93 @@
                             nstocks_limit,
                             stop_loss,
                             take_profit,
                             price=price.values,
                             ranking=rank.values)
 
         return pd.DataFrame(ret, index=entry.index, columns=entry.columns)
+
+
+
+@functools.lru_cache
+def calc_disclosure_dates(detail=True):
+
+  cinfo = data.get('company_basic_info').copy()
+  cinfo['id'] = cinfo.stock_id.str.split(' ').str[0]
+  cinfo = cinfo.set_index('id')
+  cinfo = cinfo[~cinfo.index.duplicated(keep='last')]
+
+  def calc_default_disclosure_dates(s):
+    sid = s.name
+    cat = cinfo.loc[sid].產業類別 if sid in cinfo.index else 'etf'
+    short_name = cinfo.loc[sid].公司簡稱 if sid in cinfo.index else 'etf'
+
+    if cat == '金融業':
+      calendar = {
+        '1': '-05-15',
+        '2': '-08-31',
+        '3': '-11-14',
+        '4': '-03-31',
+      }
+    elif cat == '金融保險業':
+      calendar = {
+        '1': '-04-30',
+        '2': '-08-31',
+        '3': '-10-31',
+        '4': '-03-31',
+      }
+    elif 'KY' in short_name:
+        calendar = {
+        'old':{
+            '1': '-05-15',
+            '2': '-08-14',
+            '3': '-11-14',
+            '4': '-03-31',
+              },
+        'new':{
+            '1': '-05-15',
+            '2': '-08-31',
+            '3': '-11-14',
+            '4': '-03-31',
+              },
+        }
+    else:
+      calendar = {
+        '1': '-05-15',
+        '2': '-08-14',
+        '3': '-11-14',
+        '4': '-03-31',
+      }
+    get_year = lambda year, season: str(year) if int(season) != 4 else str(int(year) + 1)
+    ky_policy_check = lambda year: 'new' if year >= '2021' else 'old'
+    return pd.to_datetime(s.index.map(lambda d: get_year(d[:4], d[-1]) + calendar[ky_policy_check(d[:4])][d[-1]]) if 'KY' in short_name else s.index.map(lambda d: get_year(d[:4], d[-1]) + calendar[d[-1]]))
+
+  def season_end(s):
+
+    calendar = {
+      '1': '-3-31',
+      '2': '-6-30',
+      '3': '-9-30',
+      '4': '-12-31',
+    }
+    return pd.to_datetime(s.index.map(lambda d: d[:4] + calendar[d[-1]]))
+
+
+  disclosure_dates = data.get('financial_statements_upload_detail:upload_date')
+  disclosure_dates = disclosure_dates.apply(pd.to_datetime)
+
+  financial_season_end = disclosure_dates.apply(season_end)
+  default_disclosure_dates = disclosure_dates.apply(calc_default_disclosure_dates)
+
+  disclosure_dates[(disclosure_dates > default_disclosure_dates)
+                    | (disclosure_dates < financial_season_end)] = pd.NaT
+  disclosure_dates[(disclosure_dates.diff() <= datetime.timedelta(days=0))] = pd.NaT
+  disclosure_dates.loc['2019-Q1', '3167'] = pd.NaT
+  disclosure_dates.loc['2015-Q1', '5536'] = pd.NaT
+  disclosure_dates.loc['2018-Q1', '5876'] = pd.NaT
+
+  disclosure_dates = disclosure_dates.fillna(default_disclosure_dates)
+  disclosure_dates.columns.name = 'stock_id'
+
+  if detail:
+    return disclosure_dates
+  return default_disclosure_dates
```

## finlab/ffn_core.py

```diff
@@ -729,15 +729,15 @@
             [
                 "worst",
                 fmtp(self.worst_day),
                 fmtp(self.worst_month),
                 fmtp(self.worst_year),
             ],
         ]
-        print(tabulate(data, headers=["daily", "monthly", "yearly"]))
+        print(tabulate(data, headers=["index", "daily", "monthly", "yearly"]))
 
         print("\nDrawdowns:")
         data = [
             [
                 fmtp(self.max_drawdown),
                 fmtp(self.avg_drawdown),
                 fmtn(self.avg_drawdown_days),
@@ -748,15 +748,15 @@
         print("\nMisc:")
         data = [
             ["avg. up month", fmtp(self.avg_up_month)],
             ["avg. down month", fmtp(self.avg_down_month)],
             ["up year %", fmtp(self.win_year_perc)],
             ["12m up %", fmtp(self.twelve_month_win_perc)],
         ]
-        print(tabulate(data))
+        print(tabulate(data, headers=["name", "value"]))
 
     def display_monthly_returns(self):
         """
         Display a table containing monthly returns and ytd returns
         for every year in range.
         """
         data = [
```

## finlab/market_info.py

```diff
@@ -1,17 +1,22 @@
 import pandas as pd
-from finlab import data
-from abc import ABC, abstractmethod
+import finlab
 
 
 class MarketInfo():
     """市場類別
     假如希望開發新的交易市場套用到回測系統，可以繼承 `finlab.market_info.MarketInfo` 來實做新類別。
     """
-    volatility = None
+    @staticmethod
+    def get_freq():
+        return '1d'
+
+    @staticmethod
+    def get_timestamp_name():
+        return 'auto'
 
     @staticmethod
     def get_benchmark():
         """設定對標報酬率的時間序列
         Returns:
           (pd.Series): 時間序列
         Examples:
@@ -19,15 +24,15 @@
             |:-----------|-------:|
             | 2007-04-23 |   100 |
             | 2007-04-24 |   100.1 |
             | 2007-04-25 |   99 |
             | 2007-04-26 |   98.3 |
             | 2007-04-27 |   99.55 |
         """
-        return pd.Series([])
+        return pd.Series([], index=pd.Index([], dtype='datetime64[ns]'), dtype='float64')
 
     @staticmethod
     def get_asset_id_to_name():
         """設定對標報酬率的時間序列
         Returns:
           (dict): 股號與股名對照表，ex:`{'2330':'台積電'}`
         """
@@ -54,70 +59,55 @@
             """
         return trade_at_price
 
 
 class TWMarketInfo(MarketInfo):
 
     @staticmethod
+    def get_freq():
+        return '1d'
+
+    @staticmethod
+    def get_timestamp_name():
+        return 'tw_stock'
+
+    @staticmethod
     def get_benchmark():
-        return data.get('benchmark_return:發行量加權股價報酬指數').squeeze()
+        return finlab.data.get('benchmark_return:發行量加權股價報酬指數').squeeze()
 
     @staticmethod
     def get_asset_id_to_name():
-        stock_names = data._storage.get_stock_names()
+        stock_names = finlab.data._storage.get_stock_names()
 
         if stock_names == {}:
-            categories = data.get('security_categories')
+            categories = finlab.data.get('security_categories')
             new_stock_names = dict(
                 zip(categories['stock_id'], categories['name']))
-            data._storage.set_stock_names(new_stock_names)
-            stock_names = data._storage.get_stock_names()
+            finlab.data._storage.set_stock_names(new_stock_names)
+            stock_names = finlab.data._storage.get_stock_names()
 
         return stock_names
 
     @staticmethod
     def get_price(trade_at_price, adj=True):
         if isinstance(trade_at_price, pd.Series):
             return trade_at_price.to_frame()
 
         if isinstance(trade_at_price, pd.DataFrame):
             return trade_at_price
 
         if isinstance(trade_at_price, str):
             if trade_at_price == 'volume':
-                return data.get('price:成交股數')
+                return finlab.data.get('price:成交股數')
 
             if adj:
                 table_name = 'etl:adj_'
                 price_name = trade_at_price
             else:
                 table_name = 'price:'
-                price_name = {'open': '開盤價', 'close': '收盤價'}[trade_at_price]
+                price_name = {'open': '開盤價', 'close': '收盤價', 'high': '最高價', 'low': '最低價'}[trade_at_price]
 
-            price = data.get(f'{table_name}{price_name}')
+            price = finlab.data.get(f'{table_name}{price_name}')
             return price
 
         raise Exception(f'**ERROR: trade_at_price is not allowed (accepted types: pd.DataFrame, pd.Series, str).')
 
-
-class CryptoMarketInfo(MarketInfo):
-
-    @staticmethod
-    def get_benchmark():
-        return data.get('crypto:close').pct_change().mean(axis=1).add(1).cumprod().resample('1d').last()
-
-    @staticmethod
-    def get_asset_id_to_name():
-        return {}
-
-    @staticmethod
-    def get_price(trade_at_price, adj=True):
-        table_name = 'crypto:'
-        if isinstance(trade_at_price, pd.Series):
-            return trade_at_price.to_frame()
-        if isinstance(trade_at_price, str):
-            price = data.get(f'{table_name}{trade_at_price}')
-        elif isinstance(trade_at_price, pd.DataFrame):
-            price = trade_at_price
-        else:
-            raise Exception(f'**ERROR: trade_at_price is not allowed (accepted types: pd.DataFrame, pd.Series, str).')
-        return price
```

## finlab/plot.py

```diff
@@ -7,43 +7,48 @@
 from finlab.utils import logger
 import itertools
 
 """
 Candles
 """
 
-
 def str_to_indicator(s, df):
     from talib import abstract
+    import talib
 
     params = {}
     if '(' in s:
         params = 'dict(' + s.split('(')[-1][:-1] + ')'
         params = eval(params)
     s = s.split('(')[0]
 
     func = getattr(abstract, s)
+    real_func = getattr(talib, s)
 
     abstract_input = list(func.input_names.values())[0]
     if isinstance(abstract_input, str):
         abstract_input = [abstract_input]
-    paras = {k: df[k] for k in abstract_input}
-    paras = {**paras, **params}
-    ret = func(**paras)
+
+    pos_paras = [df[k] for k in abstract_input]
+
+    
+    ret = real_func(*pos_paras, **params)
 
     if isinstance(ret, np.ndarray):
-       ret = pd.Series(ret, index=df.index)
+        ret = pd.Series(ret, index=df.index)
 
     if isinstance(ret, pd.Series):
         return ret.to_frame(s)
     return ret
 
+
 def color_generator():
-  for i in itertools.cycle(px.colors.qualitative.Plotly):
-    yield i
+    for i in itertools.cycle(px.colors.qualitative.Plotly):
+        yield i
+
 
 def average(series, n):
     return series.rolling(n, min_periods=int(n / 2)).mean()
 
 
 def create_bias_df(df, ma_value=20, bias_multiple=2):
     bias_df = pd.DataFrame()
@@ -57,16 +62,16 @@
 
 def create_stoch_df(df, **kwargs):
     from talib import abstract
     kd = abstract.STOCH(df['high'], df['low'], df['close'], **kwargs)
     kd = pd.DataFrame({'k': kd[0], 'd': kd[1]}, index=df.index)
     return kd
 
-def evaluate_to_df(node, stock_id, df):
 
+def evaluate_to_df(node, stock_id, df):
     if callable(node):
         node = node(df)
 
     if isinstance(node, str):
         node = str_to_indicator(node, df)
 
     if isinstance(node, pd.Series):
@@ -77,15 +82,15 @@
 
     if isinstance(node, pd.DataFrame):
         if stock_id in node.columns:
             return pd.DataFrame({'0': node[stock_id]})
         else:
             return node
 
-    if isinstance(node, list):
+    if isinstance(node, list) or isinstance(node, tuple):
         new_node = {}
         ivalue = 0
         for n in node:
             if isinstance(n, str):
                 new_node[n] = n
             else:
                 new_node[ivalue] = n
@@ -100,149 +105,128 @@
                 nn.columns = [name]
             dfs.append(nn)
 
         return pd.concat(dfs, axis=1)
 
     assert 0
 
-def format_indicators(indicators, stock_id, stock_df):
 
+def format_indicators(indicators, stock_id, stock_df):
     if not isinstance(indicators, list):
         indicators = [indicators]
 
     ret = [evaluate_to_df(i, stock_id, stock_df) for i in indicators]
 
     return ret
 
 
 def plot_candles(stock_id, close, open_, high, low, volume, recent_days=250, resample='D', overlay_func=None,
                  technical_func=None):
-
     c = color_generator()
     next(c)
     next(c)
 
     df = (pd.DataFrame({
-            'close': close.values,
-            'open': open_.values,
-            'high': high.values,
-            'low': low.values,
-            'volume': volume.values}, index=close.index).iloc[-recent_days:]
-        )
+        'close': close.values,
+        'open': open_.values,
+        'high': high.values,
+        'low': low.values,
+        'volume': volume.values}, index=close.index).iloc[-abs(recent_days):]
+    )
 
     if resample:
-        df.resample(resample).agg({
+        df = df.resample(resample).agg({
             'close': 'last',
             'open': 'first',
             'high': 'max',
             'low': 'min',
             'volume': 'sum'})
 
-    if recent_days:
-        df = df.iloc[-abs(recent_days):]
-
     if overlay_func is None:
-      overlay_func = create_bias_df(df)
+        overlay_func = create_bias_df(df)
 
     if technical_func is None:
-      technical_func = create_stoch_df(df)
+        technical_func = create_stoch_df(df)
 
     overlay_indicator = format_indicators(overlay_func, stock_id, df)
 
     # merge overlay indicator if it has multiple plots
     if len(overlay_indicator) > 1:
         overlay_indicator = [pd.concat(overlay_indicator, axis=1)]
         overlay_indicator[0].columns = range(len(overlay_indicator[0].columns))
 
     technical_indicator = format_indicators(technical_func, stock_id, df)
 
-
     # truncate recent days
-
     for i, d in enumerate(overlay_indicator):
-      overlay_indicator[i] = d.iloc[-abs(recent_days):]
+        o_ind = d.iloc[-abs(recent_days):]
+        if resample != 'D':
+            o_ind = o_ind.reindex(df.index, method='ffill')
+        overlay_indicator[i] = o_ind
     for i, d in enumerate(technical_indicator):
-      technical_indicator[i] = d.iloc[-abs(recent_days):]
+        t_ind = d.iloc[-abs(recent_days):]
+        if resample != 'D':
+            t_ind = t_ind.reindex(df.index, method='ffill')
+        technical_indicator[i] = t_ind
 
     technical_func_num = len(technical_indicator)
     index_value = close.index
 
     nrows = 1 + len(technical_indicator)
 
     fig = make_subplots(
         rows=nrows,
         specs=[[{"secondary_y": True}]] * nrows,
         shared_xaxes=True,
         vertical_spacing=0.05,
-        row_heights=[0.4] + [0.1] * (nrows-1))
+        row_heights=[0.4] + [0.1] * (nrows - 1))
 
     fig.add_trace(
-        go.Bar(x=df.index, y=df.volume, opacity=0.3, name="volume", marker={'color':'gray'}),
+        go.Bar(x=df.index, y=df.volume, opacity=0.3, name="volume", marker={'color': 'gray', 'line_width': 0}),
         row=1, col=1
     )
 
     fig.add_trace(go.Candlestick(x=df.index,
                                  open=df.open,
                                  high=df.high,
                                  low=df.low,
                                  close=df.close,
                                  increasing_line_color='#ff5084',
                                  decreasing_line_color='#2bbd91',
-                                 legendgroup='1'
+                                 legendgroup='1',
+                                 name='candle',
                                  ), row=1, col=1, secondary_y=True)
 
-    fig.add_trace(
-        go.Scatter(x = [df.index[-1]], y = [df.close[-1]],
-            mode = 'markers + text',
-            marker = {'color':'gray', 'size':0},
-            opacity=0.7,
-            showlegend = False,
-            text = [round(df.close[-1], 2)],
-            textposition='middle right'),
-    row=1, col=1, secondary_y=True)
-
-
     # overlay plot
     if overlay_indicator:
-      fig_overlay = px.line(overlay_indicator[0])
-      for o in fig_overlay.data:
-          fig.add_trace(go.Scatter(x=o['x'], y=o['y'], name=o['name'], line=dict(color=next(c)), legendgroup = "1"),
-                        row=1, col=1, secondary_y=True)
+        fig_overlay = px.line(overlay_indicator[0])
+        for o in fig_overlay.data:
+            fig.add_trace(go.Scatter(x=o['x'], y=o['y'], name=o['name'], line=dict(color=next(c)), legendgroup="1"),
+                          row=1, col=1, secondary_y=True)
 
     fig_titles = []
 
     for num, tech_ind in enumerate(technical_indicator):
         fig_tech = px.line(tech_ind)
         for t in fig_tech.data:
-
             color = next(c)
 
             fig.add_trace(
                 go.Scatter(x=t['x'], y=t['y'], name=t['name'], line=dict(color=color),
-                           legendgroup = str(2+num),
-
-                          ),
-                row=2+num, col=1)
+                           legendgroup=str(2 + num),
 
-            fig.add_trace(
-                go.Scatter(x = [t.x[-1]], y = [t.y[-1]],
-                     mode = 'markers + text',
-                     marker = {'color':color, 'size':5},
-                     showlegend = False,
-
-                     text = [round(t.y[-1], 1)],
-                     textposition='middle right'),
-                row=2+num, col=1, secondary_y=True)
+                           ),
+                row=2 + num, col=1)
 
         fig_titles.append(" , ".join([t.name for t in fig_tech.data]))
 
     # hide holiday
     if resample == 'D':
         dt_all = pd.date_range(start=index_value[0], end=index_value[-1])
-        # retrieve the dates that ARE in the original datset
+        # retrieve the dates that are in the original dataset
         dt_obs = [d.strftime("%Y-%m-%d") for d in pd.to_datetime(index_value)]
         # define dates with missing values
         dt_breaks = [d for d in dt_all.strftime("%Y-%m-%d").tolist() if d not in dt_obs]
         # hide dates with no values
         fig.update_xaxes(rangebreaks=[dict(values=dt_breaks)])
 
     fig.update_layout(
@@ -269,25 +253,23 @@
                 color="#777"
             ),
             showgrid=False
         ),
         hovermode='x unified',
     )
 
-
-
     fig.update_layout(**{
-      'xaxis1_rangeslider_visible': False,
-        f'xaxis':dict(
+        'xaxis1_rangeslider_visible': False,
+        f'xaxis': dict(
             rangeselector=dict(
                 buttons=list([
-                    dict(count=1,
-                         label="1m",
-                         step="month",
-                         stepmode="backward"),
+                    #                 dict(count=3,
+                    #                      label="3m",
+                    #                      step="month",
+                    #                      stepmode="backward"),
                     dict(count=6,
                          label="6m",
                          step="month",
                          stepmode="backward"),
                     dict(count=1,
                          label="YTD",
                          step="year",
@@ -295,57 +277,50 @@
                     dict(count=1,
                          label="1y",
                          step="year",
                          stepmode="backward"),
                     dict(step="all")
                 ])
             ),
-          ),
+        ),
         f'xaxis{nrows}': dict(
             rangeslider=dict(
                 visible=True,
                 thickness=0.1,
                 bgcolor='gainsboro',
-                range=[df.index[-30], df.index[-1]]
             ),
             type="date",
         ),
     })
 
-
-
     # fig.update_traces(xaxis='x2')
     fig.update_xaxes(showspikes=True)
     fig.update_yaxes(showspikes=True, spikemode="across")
 
     fig.update_layout(showlegend=False)
 
+    fig.update_layout({f'xaxis{i + 1}': {'title': t, 'side': 'right'} for i, t in enumerate(fig_titles)})
+    fig.update_layout({f'yaxis{i * 2 + 4}': {'showticklabels': False} for i, t in enumerate(fig_titles)})
+    fig.update_layout({f'yaxis{i * 2 + 4}': {'showticklabels': False} for i, t in enumerate(fig_titles)})
 
-    fig.update_layout({f'xaxis{i+1}':{'title': t, 'side': 'right'} for i, t in enumerate(fig_titles)})
-    fig.update_layout({f'yaxis{i*2+4}':{'showticklabels':False} for i, t in enumerate(fig_titles)})
-    fig.update_layout({f'yaxis{i*2+4}':{'showticklabels':False} for i, t in enumerate(fig_titles)})
-
-    fig.update_layout(plot_bgcolor = "white")
+    fig.update_layout(plot_bgcolor="white")
     fig.update_xaxes(showline=True, linecolor='#ddd')
     fig.update_yaxes(showline=True, linecolor='#ddd')
     fig.update_yaxes(titlefont=dict(
-                color="#777"
-            ),
-            tickfont=dict(
-                color="#777"
-            ))
+        color="#777"
+    ),
+        tickfont=dict(
+            color="#777"
+        ))
 
-    fig.update_layout(title={'text':f'Candlestick Plot {stock_id}', 'font': {'size': 18, 'color': 'gray'}})
-    #fig.update_xaxes(showgrid=True, gridwidth=1, gridcolor='#ddd')
-    #fig.update_yaxes(showgrid=True, gridwidth=1, gridcolor='#ddd')
-    #fig.update_layout({f'yaxis{i*2+4}':{'showgrid':True, 'gridcolor':'#eee'} for i, t in enumerate(fig_titles)})
-    #fig.update_layout({f'xaxis{i*2+4}':{'showgrid':True, 'gridcolor':'#eee'} for i, t in enumerate(fig_titles)})
+    fig.update_layout(title={'text': f'Candlestick Plot {stock_id}', 'font': {'size': 18, 'color': 'gray'}})
 
     return fig
 
+
 def plot_tw_stock_candles(stock_id, recent_days=400, adjust_price=False, resample='D', overlay_func=None,
                           technical_func=None):
     """繪製台股技術線圖圖組
     Args:
         stock_id (str): 台股股號，ex:`'2330'`。
         recent_days (int):取近n個交易日資料。
         adjust_price (bool):是否使用還原股價計算。
@@ -391,31 +366,30 @@
         k,d = indicator('STOCH')
         rsi = indicator('RSI')
         technical_func = [{'K':k,'D':d},{'RSI':rsi}]
         plot_tw_stock_candles(stock_id='2330',recent_days=600,adjust_price=False,overlay_func=overlay_func,technical_func=technical_func)
         ```
     """
     if adjust_price:
-        close = data.get('etl:adj_close').iloc[-recent_days:][stock_id]
-        open_ = data.get('etl:adj_open').iloc[-recent_days:][stock_id]
-        high = data.get('etl:adj_high').iloc[-recent_days:][stock_id]
-        low = data.get('etl:adj_low').iloc[-recent_days:][stock_id]
+        close = data.get('etl:adj_close')[stock_id]
+        open_ = data.get('etl:adj_open')[stock_id]
+        high = data.get('etl:adj_high')[stock_id]
+        low = data.get('etl:adj_low')[stock_id]
     else:
-        close = data.get('price:收盤價').iloc[-recent_days:][stock_id]
-        open_ = data.get('price:開盤價').iloc[-recent_days:][stock_id]
-        high = data.get('price:最高價').iloc[-recent_days:][stock_id]
-        low = data.get('price:最低價').iloc[-recent_days:][stock_id]
+        close = data.get('price:收盤價')[stock_id]
+        open_ = data.get('price:開盤價')[stock_id]
+        high = data.get('price:最高價')[stock_id]
+        low = data.get('price:最低價')[stock_id]
 
-    volume = data.get('price:成交股數').iloc[-recent_days:][stock_id]
+    volume = data.get('price:成交股數')[stock_id]
 
     return plot_candles(stock_id, close, open_, high, low, volume, recent_days=recent_days, resample=resample,
                         overlay_func=overlay_func, technical_func=technical_func)
 
 
-
 """
 Treemap
 """
 
 
 def df_date_filter(df, start=None, end=None):
     if start:
@@ -586,15 +560,15 @@
 
 
 """
 Radar
 """
 
 
-def plot_radar(df, mode='line_polar', line_polar_fill=None, title=None):
+def plot_radar(df, mode='line_polar', line_polar_fill=None, title=None, polar_range=10):
     args = dict(data_frame=df, r="value", theta="variable", color="stock_id", line_close=True,
                 color_discrete_sequence=px.colors.sequential.Plasma_r,
                 template="plotly_dark")
     if mode != 'line_polar':
         args.pop('line_close')
 
     fig = getattr(px, mode)(**args)
@@ -604,43 +578,52 @@
         title={
             'text': title,
             'x': 0.49,
             'y': 0.99,
             'xanchor': 'center',
             'yanchor': 'top'},
         paper_bgcolor='rgb(41, 30, 109)',
+        polar=dict(
+            radialaxis=dict(
+                visible=True,
+                range=[0, polar_range]
+            )),
         width=1200,
         height=600)
     if mode == 'line_polar':
         # None,toself,tonext
         fig.update_traces(fill=line_polar_fill)
     return fig
 
 
-def get_rank(item: str, data_position=-1, cut_bins=10):
+def get_rank(item: str, period=None, cut_bins=10):
     df = data.get(item)
-    df_rank = df.iloc[data_position].rank(pct=True)
+    if period == None:
+        df = df.iloc[-1]
+    else:
+        df = df.loc[period]
+
+    df_rank = df.rank(pct=True)
     df_rank = pd.cut(x=df_rank, bins=cut_bins, labels=[i for i in range(1, cut_bins + 1)])
     return df_rank
 
 
-def get_rank_df(feats: list, data_position=-1, cut_bins=10):
-    df = pd.concat([get_rank(f, data_position, cut_bins) for f in feats], axis=1)
+def get_rank_df(feats: list, period=None, cut_bins=10):
+    df = pd.concat([get_rank(f, period, cut_bins) for f in feats], axis=1)
     columns_name = [f[f.index(':') + 1:] for f in feats]
-    df = df.fillna(1)
     df.columns = columns_name
     df.index.name = 'stock_id'
     return df
 
 
 def plot_tw_stock_radar(portfolio, feats=None, mode='line_polar', line_polar_fill=None,
-                        data_position=-1, cut_bins=10, title=None, custom_data=None):
+                        period=None, cut_bins=10, title=None, custom_data=None):
     """繪製台股雷達圖
 
-    比較持股組合的指標分級特性。
+    比較持股組合的指標分級特性。若數值為nan，則不顯示分級。
 
     Args:
       portfolio (list):持股組合，ex:`['1101','1102']`。
       feats (list): 選定FinLab資料庫內的指標組成資料集。預設為18項財務指標。
                     ex:['fundamental_features:營業毛利率','fundamental_features:營業利益率']
       mode (str): 雷達圖模式 ，ex:`'line_polar','bar_polar','scatter_polar'`。
         !!!note
@@ -650,15 +633,16 @@
                            `'toself'`將跡線的端點（或跡線的每一段，如果它有間隙）連接成一個封閉的形狀。
                            如果一條完全包圍另一條（例如連續的等高線），則`'tonext'`填充兩條跡線之間的空間，如果之前沒有跡線，
                            則其行為類似於`'toself'`。如果一條跡線不包含另一條跡線，則不應使用`'tonext'`。
         !!!note
 
             參考[plotly.graph_objects.Scatterpolar.fill](https://plotly.github.io/plotly.py-docs/generated/plotly.graph_objects.Scatterpolar.html)
 
-      data_position (int) : 選擇第幾期的特徵資料，ex: -2為近第2期資料。
+      period (str): 選擇第幾期的特徵資料，預設為近一季。
+                    ex: 設定數值為'2020-Q2，取得2020年第二季資料比較。
       cut_bins (int):特徵分級級距。
       title (str):圖片標題名稱。
       custom_data (pd.DataFrame): 客製化指標分級，欄名為特徵
                     格式範例:
 
         | stock_id   |  營業毛利率 |營業利益率|稅後淨利率|
         |:-----------|-------:|-------:|-------:|
@@ -688,27 +672,28 @@
                      'fundamental_features:ROA綜合損益', 'fundamental_features:ROE綜合損益', 'fundamental_features:業外收支營收率',
                      'fundamental_features:現金流量比率', 'fundamental_features:負債比率',
                      'fundamental_features:流動比率', 'fundamental_features:速動比率', 'fundamental_features:存貨週轉率',
                      'fundamental_features:營收成長率', 'fundamental_features:營業毛利成長率',
                      'fundamental_features:營業利益成長率', 'fundamental_features:稅前淨利成長率', 'fundamental_features:稅後淨利成長率',
                      'fundamental_features:資產總額成長率', 'fundamental_features:淨值成長率'
                      ]
-        df = get_rank_df(feats, data_position=data_position, cut_bins=cut_bins)
+        df = get_rank_df(feats, period=period, cut_bins=cut_bins)
     else:
         df = custom_data.copy()
 
     col_name = df.columns
     portfolio = df.index.intersection(portfolio)
     if len(portfolio) < 1:
         logger.error('data is not existed.')
         return
     df = df.loc[portfolio]
     df = df.reset_index()
     df = pd.melt(df, id_vars=['stock_id'], value_vars=col_name)
-    fig = plot_radar(df=df, mode=mode, line_polar_fill=line_polar_fill, title=title)
+    polar_range = cut_bins * len(portfolio)
+    fig = plot_radar(df=df, mode=mode, line_polar_fill=line_polar_fill, title=title, polar_range=polar_range)
     return fig
 
 
 """
 PE PB River
 """
 
@@ -809,15 +794,15 @@
         if s_name == '現金':
             result = pd.DataFrame({'return': 0, 'weight': 1, 'category': '現金', 'market': '現金'}, index=['現金'])
             result.index.name = 'stock_id'
         else:
             df = pd.DataFrame(self.s_data[s_name]['positions'])
             df = df.drop(columns=['last_updated', 'next_trading_date', 'trade_at', 'update_date'])
             df = df.T
-            df['weight'] = abs(df['weight'])
+            df['weight'] = df['weight'].apply(lambda s: abs(pd.to_numeric(s, errors='coerce')))
             df = df[df['weight'] > 0]
             if len(df) == 0:
                 df['weight'] = 0
             df.index.name = 'stock_id'
             old_security_categories = data.get('security_categories')
             security_categories = old_security_categories.copy()
             security_categories['category'] = security_categories['category'].fillna('other_securities')
@@ -861,14 +846,16 @@
         all_position = pd.concat([self.process_position(name, weight) for name, weight in zip(s_name, s_weight)])
         all_position['weight'] *= all_position['s_weight']
         all_position['return'] = round(all_position['return'].astype(float), 2)
         all_position['color'] = round(
             all_position['return'].clip(all_position['return'].min() / 2, all_position['return'].max() / 2), 2)
         all_position = all_position[all_position['weight'] > 0]
         all_position = all_position.reset_index()
+        all_position = all_position[all_position['s_name'] != 'playground']
+        all_position['category'] = all_position['category'].fillna('other_securities')
         return all_position
 
     def plot(self, select_strategy=None, path=None, color_continuous_scale='RdBu_r'):
         """繪圖
 
         Args:
           select_strategy (dict): 選擇策略名稱並設定權重，預設是抓取權策略並平分資金比例到各策略。
```

## finlab/analysis/__init__.py

```diff
@@ -8,15 +8,14 @@
         """Check if market info is supported
 
         Returns:
           (bool): True, support. False not support.
         """
         return True
 
-    @staticmethod
     def calculate_trade_info(self, report):
         """Additional trade info can be calculated easily.
 
         User could override this function if additional trade info is required for later anlaysis.
 
         Examples:
 
@@ -61,15 +60,15 @@
         Args:
           creturn (pd.Series): 策略報酬率時間序列。
           position (pd.DataFrame): 策略報酬率時間序列。
           fee_ratio (float): 交易手續費率，預設為台灣無打折手續費 0.001425。可視個人使用的券商優惠調整費率。
           tax_ratio (float): 交易稅率，預設為台灣普通股一般交易交易稅率 0.003。若交易策略的標的皆為 ETF，記得設成 0.001。
           trade_at (str): 選擇回測之還原股價以收盤價或開盤價計算，預設為 close。可選 close 或 open。
           next_trading_date (str): 預期下期換股日。
-          market_info (str or class(finlab.market_info.MarketInfo) ): 可選擇`'TWSTOCK', 'CRYPTO'`，分別為台股或加密貨幣，
+          market_info (str or MarketInfo): 可選擇`'TWSTOCK', 'CRYPTO'`，分別為台股或加密貨幣，
                                                                      或繼承 `finlab.market_info.MarketInfo` 開發回測市場類別。
         Attributes:
           benchmark (pd.Series): 對標報酬率曲線的時間序列，用於 Report.display() 顯示策略報酬率比較標準。
           update_date (str): 用於 Report.display() 顯示策略對標的報酬率曲線。
           asset_type (str): 資產類別， tw_stock 或 crypto。
           last_trading_date (str): 最近產生交易訊號的日期。
         """
@@ -116,29 +115,28 @@
           (pd.DataFrame): 波動時序資料
         """
         return super().get_mae_mfe()
 
     def get_trades(self):
         """取得回測逐筆交易紀錄
         ## 重點欄位說明
-        * exit_sig_date:進場訊號產生日。
-        * entry_sig_date:出場訊號產生日。
+        * entry_sig_date:進場訊號產生日。
+        * exit_sig_date:出場訊號產生日。
         * entry_date:進場日。
         * exit_date:出場日。
         * position:持有佔比。
         * period:持有天數。
         * return:報酬率。
         * trade_price@entry_date:進場價。
         * trade_price@exit_date:出場價。
         * mae:持有期間最大不利報酬率幅度。
         * gmfe:持有期間最大有利報酬率幅度。
         * bmfe:mae發生前的最大有利報酬率幅度。
         * mdd:持有期間最大回撤。
         * pdays:處於獲利時的天數。
-        * entry_volatility@entry_sig_date: 進場訊號產生日的股價真實波動率。
 
         Returns:
           (pd.DataFrame): 交易紀錄
         """
         return super().get_trades()
 
     def get_stats(self, resample='1d', riskfree_rate=0.02):
```

## finlab/analysis/liquidityAnalysis.py

```diff
@@ -1,15 +1,15 @@
 import pandas as pd
 from finlab import data
 from finlab.analysis import Analysis
 
 
 class LiquidityAnalysis(Analysis):
 
-  def __init__(self, required_volume=200000, required_turnover=1000000):
+  def __init__(self, required_volume=200000, required_turnover=1000000, detail=True):
     """分析台股策略流動性風險項目的機率
 
     !!! note
         參考[VIP限定文章](https://www.finlab.tw/customized_liquidityanalysis/)更了解流動性檢測內容細節。
     Args:
         required_volume (int): 要求進出場時的單日成交股數至少要多少？
         required_turnover (int): 要求進出場時的單日成交金額至少要多少元？避免成交股數夠，但因低價股因素，造成胃納量仍無法符合資金需求。
@@ -25,14 +25,15 @@
         report.run_analysis(LiquidityAnalysis(required_volume=100000))
         ```
     """
 
     self._required_volume = required_volume
     self._required_turnover = required_turnover
     self._result = None
+    self._detail = detail
 
   def is_market_info_supported(self, market_info):
     return 'TWMarketInfo' in str(market_info)
 
   def calculate_trade_info(self, report):
 
     # calculate trade bar return
@@ -44,20 +45,24 @@
     volume = report.market_info.get_price('volume', adj=False)
 
     signal_dates = ["entry_date", "exit_date"]
 
     ret = [
       ["交易當下漲跌", adj_trade_price / adj_previous_close - 1, signal_dates],
       ["交易金額", trade_price * volume, signal_dates],
-      ["成交股數", volume, signal_dates],
-      ["處置股", ~data.get('etl:disposal_stock_filter').shift(fill_value=False), signal_dates],
-      ["警示股", ~data.get('etl:disposal_stock_filter').shift(fill_value=False), signal_dates],
-      ["全額交割股", ~data.get('etl:full_cash_delivery_stock_filter').shift(fill_value=False), signal_dates]
+      ["成交股數", volume, signal_dates]
     ]
 
+    if self._detail:
+        ret += [
+          ["處置股", ~data.get('etl:disposal_stock_filter').shift(fill_value=False), signal_dates],
+          ["警示股", ~data.get('etl:disposal_stock_filter').shift(fill_value=False), signal_dates],
+          ["全額交割股", ~data.get('etl:full_cash_delivery_stock_filter').shift(fill_value=False), signal_dates]
+        ]
+
     return ret
 
   def analyze(self, report):
     trades = report.get_trades()
 
     entry_pct_range = (trades.entry_date >= '2015-6-1') * 0.03 + 0.07
     exit_pct_range = (trades.exit_date >= '2015-6-1') * 0.03 + 0.07
@@ -68,29 +73,35 @@
     entry_sell_at_bottom = (~long_position) & (trades['交易當下漲跌@entry_date'] < -entry_pct_range * 0.95)
 
     exit_sell_at_bottom = long_position & (trades['交易當下漲跌@exit_date'] < -exit_pct_range * 0.95)
     exit_buy_at_top = (~long_position) & (trades['交易當下漲跌@exit_date'] > exit_pct_range * 0.95)
 
     trade_pct_count = trades['交易當下漲跌@entry_date'].notna() & trades['交易當下漲跌@exit_date'].notna()
 
-    self._result = pd.DataFrame({
+    ret_dict = {
       '買遇漲停': [entry_buy_at_top.mean(), exit_buy_at_top.mean()],
       '賣遇跌停': [entry_sell_at_bottom.mean(), exit_sell_at_bottom.mean()],
       '成交股數少': [(trades['成交股數@entry_date'] < self._required_volume).mean(),
                      (trades['成交股數@exit_date'] < self._required_volume).mean()],
       '交易金額少': [(trades['交易金額@entry_date'] < self._required_turnover).mean(),
                      (trades['交易金額@exit_date'] < self._required_turnover).mean()],
-      '處置股': [trades['處置股@entry_date'].mean(), trades['處置股@exit_date'].mean()],
-      '警示股': [trades['警示股@entry_date'].mean(), trades['警示股@exit_date'].mean()],
-      '全額交割股':[trades['全額交割股@entry_date'].mean(), trades['全額交割股@exit_date'].mean()],
-    })
+    }
+
+    if self._detail:
+        ret_dict = {**ret_dict, **{
+            '處置股': [trades['處置股@entry_date'].mean(), trades['處置股@exit_date'].mean()],
+            '警示股': [trades['警示股@entry_date'].mean(), trades['警示股@exit_date'].mean()],
+            '全額交割股':[trades['全額交割股@entry_date'].mean(), trades['全額交割股@exit_date'].mean()]
+        }}
+
+    self._result = pd.DataFrame(ret_dict)
 
     self._result.index = ['進場', '出場']
 
-    return self._result
+    return self._result.to_dict()
 
   def display(self):
 
     def percentage(v):
         return str(round(v*100, 1)) + '%'
 
     def make_pretty(styler):
```

## finlab/online/base_account.py

```diff
@@ -1,16 +1,20 @@
 from abc import ABC, abstractmethod
 from dataclasses import dataclass
 from typing import Any
 
+import pkg_resources
 import pandas as pd
 import numpy as np
+import importlib
 import datetime
 import numbers
 import os
+
+from finlab import logger
 from finlab.online.enums import *
 from finlab.online.order_executor import Position
 
 
 @dataclass
 class Order():
 
@@ -38,105 +42,14 @@
     quantity: numbers.Number
     filled_quantity: numbers.Number
     status: OrderStatus
     order_condition: OrderCondition
     time: datetime.datetime
     org_order: Any = None
 
-    @classmethod
-    def from_shioaji(cls, trade):
-        """將 shioaji package 的委託單轉換成 finlab 格式"""
-        if trade.order.action == 'Buy':
-            action = Action.BUY
-        elif trade.order.action == 'Sell':
-            action = Action.SELL
-        else:
-            raise Exception('trader order action should be "Buy" or "Sell"')
-
-        status = {
-            'PendingSubmit': OrderStatus.NEW,
-            'PreSubmitted': OrderStatus.NEW,
-            'Submitted': OrderStatus.NEW,
-            'Failed': OrderStatus.CANCEL,
-            'Cancelled': OrderStatus.CANCEL,
-            'Filled': OrderStatus.FILLED,
-            'Filling': OrderStatus.PARTIALLY_FILLED,
-            'PartFilled': OrderStatus.PARTIALLY_FILLED,
-        }[trade.status.status]
-
-        order_condition = {
-            'Cash': OrderCondition.CASH,
-            'MarginTrading': OrderCondition.MARGIN_TRADING,
-            'ShortSelling': OrderCondition.SHORT_SELLING,
-        }[trade.order.order_cond]
-
-        # calculate quantity
-        # calculate filled quantity
-        quantity = trade.order.quantity
-        filled_quantity = trade.status.deal_quantity
-
-        if trade.order.order_lot == 'IntradayOdd':
-            quantity /= 1000
-
-        # calculate order condition
-        if trade.order.first_sell == 'true' and order_condition == OrderCondition.CASH:
-            order_condition = OrderCondition.DAY_TRADING_SHORT
-
-        return cls(**{
-            'order_id': trade.status.id,
-            'stock_id': trade.contract.code,
-            'action': action,
-            'price': trade.order.price if trade.status.modified_price == 0 else trade.status.modified_price,
-            'quantity': quantity,
-            'filled_quantity': filled_quantity,
-            'status': status,
-            'order_condition': order_condition,
-            'time': trade.status.order_datetime,
-            'org_order': trade
-        })
-
-    @classmethod
-    def from_fugle(cls, order):
-        """將 fugle package 的委託單轉換成 finlab 格式"""
-
-        status = OrderStatus.NEW
-        if order['mat_qty'] + order['cel_qty'] > 0:
-            status = OrderStatus.PARTIALLY_FILLED
-        if order['org_qty'] - order['mat_qty'] - order['cel_qty'] == 0:
-            status = OrderStatus.FILLED
-        if order['cel_qty'] == order['org_qty'] or order['err_code'] != '00000000':
-            status = OrderStatus.CANCEL
-
-        order_condition = {
-            '0': OrderCondition.CASH,
-            '3': OrderCondition.MARGIN_TRADING,
-            '4': OrderCondition.SHORT_SELLING,
-            '9': OrderCondition.DAY_TRADING_LONG,
-            'A': OrderCondition.DAY_TRADING_SHORT,
-        }[order['trade']]
-
-        filled_quantity = order['mat_qty']
-
-        order_id = order['ord_no']
-        if order_id == '':
-            order_id = order['pre_ord_no']
-
-        return cls(**{
-            'order_id': order_id,
-            'stock_id': order['stock_no'],
-            'action': Action.BUY if order['buy_sell'] == 'B' else Action.SELL,
-            'price': order.get('od_price', order['avg_price']),
-            'quantity': order['org_qty'],
-            'filled_quantity': filled_quantity,
-            'status': status,
-            'order_condition': order_condition,
-            'time': datetime.datetime.strptime(order['ord_date'] + order['ord_time'], '%Y%m%d%H%M%S%f'),
-            'org_order': order
-        })
-
 
 @dataclass
 class Stock():
 
     """
     Stock
 
@@ -163,58 +76,39 @@
     bid_volume: numbers.Number
     ask_price: numbers.Number
     ask_volume: numbers.Number
 
     def to_dict(self):
         return {a: getattr(self, a) for a in Stock.attrs}
 
-    @classmethod
-    def from_shioaji(cls, snapshot):
-        """將 shioaji 股價行情轉換成 finlab 格式"""
-        d = snapshot
-        return cls(stock_id=d.code, open=d.open, high=d.high, low=d.low, close=d.close,
-                   bid_price=d.buy_price, ask_price=d.sell_price, bid_volume=d.buy_volume, ask_volume=d.sell_volume)
-
-    @classmethod
-    def from_fugle(cls, json_response):
-        """將 fugle 股價行情轉換成 finlab 格式"""
-        r = json_response
-
-        if 'data' not in r:
-            raise Exception('Cannot parse fugle quote data' + str(r))
-
-        bids = r['data']['quote']['order']['bids']
-        asks = r['data']['quote']['order']['asks']
-        has_volume = 'trade' in r['data']['quote']
-        return cls(
-            stock_id=r['data']['info']['symbolId'],
-            high=r['data']['quote']['priceHigh']['price'] if has_volume else 0,
-            low=r['data']['quote']['priceLow']['price'] if has_volume else 0,
-            close=r['data']['quote']['trade']['price'] if has_volume else 0,
-            open=r['data']['quote']['priceOpen']['price'] if has_volume else 0,
-            bid_price=bids[0]['price'] if bids else np.nan,
-            ask_price=asks[0]['price'] if asks else np.nan,
-            bid_volume=bids[0]['volume'] if bids else np.nan,
-            ask_volume=asks[0]['volume'] if asks else np.nan,
-        )
-
 
 class Account(ABC):
     """股票帳戶的 abstract class
     可以繼承此 Account，來實做券商的帳戶買賣動作，目前已經實做 SinopacAccount (永豐證券) 以及 FugleAccount (玉山富果)，來進行交易。可以用以下方式建構物件並用來交易：
 
     永豐證券
     ```py
     import os
     from finlab.online.sinopac_account import SinopacAccount
 
+
+    # 舊版請使用
+    # shioaji < 1.0.0 and finlab < 0.3.18
     os.environ['SHIOAJI_ACCOUNT']= '永豐證券帳號'
     os.environ['SHIOAJI_PASSWORD']= '永豐證券密碼'
+
+    # 新版請使用
+    # shioaji >= 1.0.0 and finlab >= 0.3.18
+    os.environ['SHIOAJI_API_KEY'] = '永豐證券API_KEY'
+    os.environ['SHIOAJI_SECRET_KEY'] = '永豐證券SECRET_KEY'
+    os.environ['SHIOAJI_CERT_PERSON_ID']= '身份證字號'
+
+    # shioaji
     os.environ['SHIOAJI_CERT_PATH']= '永豐證券憑證路徑'
-    os.environ['SHIOAJI_CERT_PASSWORD'] = '永豐證券憑證密碼' # 預設與身份證同
+    os.environ['SHIOAJI_CERT_PASSWORD'] = '永豐證券憑證密碼' # 預設與身份證字號
 
     acc = SinopacAccount()
     ```
     玉山富果:
     ```py
     from finlab.online.fugle_account import FugleAccount
     import os
@@ -222,70 +116,113 @@
     os.environ['FUGLE_MARKET_API_KEY'] = '玉山富果的行情API Token'
 
     acc = FugleAccount()
     ```
 
     """
 
+    @classmethod
+    def check_version(self):
+
+        m = self.required_module
+        v = self.module_version
+
+        # check module installed
+        if importlib.util.find_spec(m) is None:
+            raise Exception(
+                f"Please install {m} using the following script: pip install {m}=={v}.")
+
+        # check module version
+        present_version = pkg_resources.get_distribution(m).version
+        if present_version > v:
+            logger.warning(
+                f'Current {m}=={present_version} may not be compatable. You could using the following command to install the compatable version: pip install {m}=={v}')
+
     @abstractmethod
     def create_order(self, action, stock_id, quantity, price=None, force=False, wait_for_best_price=False):
         """產生新的委託單
 
         Attributes:
             action (Action): 買賣方向，通常為 'BUY' 或是 'SELL'
             stock_id (str): 股票代號 ex: '2330'
             quantity (numbers.Number): 委託股票的總數量（張數），允許小數點
             price (numbers.Number, optional): 股票買賣的價格(限價單)
             force (bool): 是否用最差之價格（長跌停）強制成交?
               當成交量足夠時，可以比較快成交，然而當成交量低時，容易有大的滑價
             wait_for_best_price (bool): 是否用最佳之價格（長跌停），無限時間等待？當今天要出場時，可以開啟等漲停價來購買，當今天要買入時，可以掛跌停價等待買入時機。
+
+        Returns:
+            (str): order id 券商提供的委託單編號
         """
         pass
 
     @abstractmethod
     def update_order(self, order_id, price=None, quantity=None):
         """產生新的委託單
 
         Attributes:
             order_id (str): 券商所提供的委託單 ID
             price (numbers.Number, optional): 更新的限價
             quantity (numbers.Number, optional): 更新的待成交量
+        Returns:
+            (None): 無跳出 erorr 代表成功更新委託單
         """
         pass
 
     @abstractmethod
     def cancel_order(self, order_id):
         """刪除委託單
 
+        建議使用 刪除委託單此功能前，先使用 update_order() 來更新委託單的狀況！如下
+        ```py
+        acc.update_order()
+        acc.cancel_order('ORDER_ID')
+        ```
+
         Attributes:
             order_id (str): 券商所提供的委託單 ID
+
+        Returns:
+            (None): 代表成功更新委託單
         """
         pass
 
     @abstractmethod
     def get_orders(self):
         """拿到現在所有委託單
+        Returns:
+            (Dict[str, Order]): 所有委託單 id 與委託單資料
+                !!! example
+                    `{'12345A': Order(order_id='12345A', stock_id='5410',...),...}`
         """
         pass
 
     @abstractmethod
     def get_stocks(self, stock_ids):
         """拿到現在股票報價
         Attributes:
             stock_ids (`list` of `str`): 一次拿取所有股票的報價，ex: ['1101', '2330']
+        Returns:
+            (dict): 報價資料，
+                !!! example
+                    `{'1101': Stock(stock_id='1101', open=31.15, high=31.85, low=31.1, close=31.65, bid_price=31.6, bid_volume=728.0, ask_price=31.65, ask_volume=202)}`
         """
         pass
 
     @abstractmethod
     def get_position(self):
-        """拿到當前帳戶的股票部位"""
+        """拿到當前帳戶的股票部位
+
+        Returns:
+            (Position): 當前股票部位
+        """
         pass
 
     @abstractmethod
-    def get_total_balance():
+    def get_total_balance(self):
         """拿到當前帳戶的股票部位淨值"""
         pass
 
     def sep_odd_lot_order(self):
         return True
 
     def get_price(self, stock_ids):
@@ -301,7 +238,10 @@
                 price[sid] = (bid_price + ask_price)/2
 
             if price[sid] == 0:
                 raise Exception(
                     f"Stock {sid} has no price to reference. Use latest close of previous trading day")
 
         return price
+
+    def on_trades(self, func):
+        pass
```

## finlab/online/enums.py

```diff
@@ -1,7 +1,7 @@
-from enum import Enum
+from enum import IntEnum as Enum
 
 OrderStatus = Enum('OrderStatus', 'NEW PARTIALLY_FILLED FILLED CANCEL')
 
 Action = Enum('Action', 'BUY SELL')
 
 OrderCondition = Enum('OrderCondition', 'CASH MARGIN_TRADING SHORT_SELLING DAY_TRADING_LONG DAY_TRADING_SHORT')
```

## finlab/online/fugle_account.py

```diff
@@ -2,25 +2,35 @@
 from fugle_trade.sdk import SDK
 from fugle_trade.order import OrderObject
 from fugle_trade.constant import Action as fugleAction
 from fugle_trade.constant import (APCode, Trade, PriceFlag, BSFlag, Action)
 
 from finlab.online.base_account import Account, Stock, Order, Position
 from finlab.online.enums import *
+
+from threading import Thread
 import requests
 import datetime
 import logging
+import math
+import copy
 import time
 import os
 
 
 class FugleAccount(Account):
 
+    required_module = 'fugle_trade'
+    module_version = '0.4.0'
+
     def __init__(self, config_path='./config.ini.example', market_api_key=None):
 
+        self.check_version()
+        self.market = 'tw_stock'
+
         self.market_api_key = market_api_key
 
         if 'FUGLE_CONFIG_PATH' in os.environ:
             config_path = os.environ['FUGLE_CONFIG_PATH']
 
         if 'FUGLE_MARKET_API_KEY' in os.environ:
             market_api_key = os.environ['FUGLE_MARKET_API_KEY']
@@ -37,14 +47,15 @@
         sdk = SDK(config)
         sdk.login()
         self.sdk = sdk
 
         self.market_api_key = market_api_key
 
         self.trades = {}
+        self.thread = None
 
     def create_order(self, action, stock_id, quantity, price=None, odd_lot=False, best_price_limit=False, market_order=False, order_cond=OrderCondition.CASH):
 
         if quantity <= 0:
             raise ValueError("quantity should be larger than zero")
 
         if best_price_limit and market_order:
@@ -69,32 +80,44 @@
             elif action == Action.SELL:
                 price_flag = PriceFlag.LimitUp
 
         order_cond = {
             OrderCondition.CASH: Trade.Cash,
             OrderCondition.MARGIN_TRADING: Trade.Margin,
             OrderCondition.SHORT_SELLING: Trade.Short,
-            OrderCondition.DAY_TRADING_LONG: Trade.DayTrading,
+            # OrderCondition.DAY_TRADING_LONG: Trade.DayTrading,
             OrderCondition.DAY_TRADING_SHORT: Trade.DayTradingSell,
         }[order_cond]
 
         ap_code = APCode.IntradayOdd if odd_lot else APCode.Common
+        now = datetime.datetime.utcnow() + datetime.timedelta(hours=8)
+        if datetime.time(13, 40) < datetime.time(now.hour, now.minute) and datetime.time(now.hour, now.minute) < datetime.time(14, 30) and odd_lot:
+            ap_code = APCode.Odd
+        if datetime.time(14, 00) < datetime.time(now.hour, now.minute) and datetime.time(now.hour, now.minute) < datetime.time(14, 30) and not odd_lot:
+            ap_code = APCode.AfterMarket
+            price_flag = PriceFlag.Limit
 
         params = dict(
             buy_sell=fugle_action,
             stock_no=stock_id,
             quantity=quantity,
             ap_code=ap_code,
             price_flag=price_flag,
             trade=order_cond,
             price=price
         )
 
         order = OrderObject(**params)
-        ret = self.sdk.place_order(order)
+
+        try:
+            ret = self.sdk.place_order(order)
+        except Exception as e:
+            logging.warning(
+                f"create_order: Cannot create order of {params}: {e}")
+            return
 
         ord_no = ret['ord_no']
         if ord_no == '':
             ord_no = ret['pre_ord_no']
         self.trades[ord_no] = ret
         return ord_no
 
@@ -108,49 +131,74 @@
 
         if order_id not in self.trades:
             logging.warning(
                 f"update_order: Order id {order_id} not found, cannot update the price.")
 
         if price is not None:
             try:
-                self.sdk.modify_price(self.trades[order_id].org_order, price)
+                if self.trades[order_id].org_order['ap_code'] == '5':
+                    fugle_order = self.trades[order_id].org_order
+                    action = Action.BUY if fugle_order['buy_sell'] == 'B' else Action.SELL
+                    stock_id = fugle_order['stock_no']
+                    q = fugle_order['org_qty_share'] - \
+                        fugle_order['mat_qty_share'] - \
+                        fugle_order['cel_qty_share']
+
+                    self.cancel_order(order_id)
+                    self.create_order(
+                        action=action, stock_id=stock_id, quantity=q, price=price, odd_lot=True)
+                else:
+                    self.sdk.modify_price(
+                        self.trades[order_id].org_order, price)
             except ValueError as ve:
-                logging.warning(f"update_order: Cannot update price: {ve}")
+                logging.warning(
+                    f"update_order: Cannot update price of order {order_id}: {ve}")
 
         if quantity is not None:
             raise NotImplementedError("Cannot change order quantity")
 
     def cancel_order(self, order_id):
         if not order_id in self.trades:
             self.trades = self.get_orders()
 
-        self.sdk.cancel_order(self.trades[order_id].org_order)
+        try:
+            self.sdk.cancel_order(self.trades[order_id].org_order)
+        except Exception as e:
+            logging.warning(
+                f"cancel_order: Cannot cancel order {order_id}: {e}")
 
     def get_orders(self):
         orders = self.sdk.get_order_results()
         ret = {}
         for o in orders:
             order_id = o['ord_no']
             if order_id == '':
                 order_id = o['pre_ord_no']
 
-            ret[order_id] = Order.from_fugle(o)
+            ret[order_id] = create_finlab_order(o)
         self.trades = ret
-        return ret
+        return copy.deepcopy(ret)
 
     def get_stocks(self, stock_ids):
         ret = {}
         for s in stock_ids:
             try:
                 res = requests.get(
                     f'https://api.fugle.tw/realtime/v0.3/intraday/quote?symbolId={s}&apiToken={self.market_api_key}')
                 json_response = res.json()
-                ret[s] = Stock.from_fugle(json_response)
+                ret[s] = to_finlab_stock(json_response)
+
+                if math.isnan(ret[s].close):
+                    res = requests.get(
+                        f'https://api.fugle.tw/realtime/v0.3/intraday/meta?symbolId={s}&apiToken={self.market_api_key}')
+                    json_response = res.json()
+                    ret[s].close = json_response['data']['meta']['priceReference']
+
             except Exception as e:
-                logging.warn(f"** Fugle API: cannot get stock {s}")
+                logging.warn(f"Fugle API: cannot get stock {s}")
                 logging.warn(e)
 
         return ret
 
     def get_position(self):
         order_condition = {
             '0': OrderCondition.CASH,
@@ -168,21 +216,132 @@
             time.sleep(10)
 
         inv = self.sdk.get_inventories()
         self.timestamp_for_get_position = now
 
         ret = []
         for i in inv:
-            total_qty = sum([int(d['qty']) for d in i['stk_dats']]) / 1000
-            ret.append({
-                'stock_id': i['stk_no'],
-                'quantity': total_qty,
-                'order_condition': order_condition[i['trade']]
-            })
 
-        return Position.from_dict(ret)
-
-    def get_total_balance():
-        raise NotImplementedError("Total balance not implemented")
+            # removed: position of stk_dats is not completed
+            # total_qty = sum([int(d['qty']) for d in i['stk_dats']]) / 1000
+            total_qty = (int(i['qty_l']) +
+                         int(i['qty_bm']) - int(i['qty_sm'])) / 1000
+
+            if total_qty != 0:
+                ret.append({
+                    'stock_id': i['stk_no'],
+                    'quantity': total_qty,
+                    'order_condition': order_condition[i['trade']]
+                })
+
+        return Position.from_list(ret)
+
+    def get_total_balance(self):
+        # get bank balance
+        bank_balance = self.sdk.get_balance()['available_balance']
+
+        # get settlements
+        settlements = self.sdk.get_settlements()
+        settlements = sum(int(settlement['price']) for settlement in settlements if datetime.datetime.strptime(
+            settlement['c_date'] + ' 10:00', '%Y%m%d %H:%M') > datetime.datetime.now())
+
+        # get position balance
+        account_balance = sum(int(inv['value_mkt'])
+                              for inv in self.sdk.get_inventories())
+        return bank_balance + settlements + account_balance
 
     def support_day_trade_condition(self):
         return True
+
+    def on_trades(self, func):
+
+        order_condition = {
+            '0': OrderCondition.CASH,
+            '3': OrderCondition.MARGIN_TRADING,
+            '4': OrderCondition.SHORT_SELLING,
+            '9': OrderCondition.DAY_TRADING_LONG,
+            'A': OrderCondition.DAY_TRADING_SHORT,
+        }
+
+        @self.acc.sdk.on('dealt')
+        def on_dealt(data):
+            if isinstance(data, dict):
+                time = (datetime.datetime.strptime(f"{str((datetime.datetime.utcnow()+datetime.timedelta(hours=8)).date())} {data['mat_time']}", "%Y-%m-%d %H%M%S%f")-datetime.timedelta(
+                    hours=8)).replace(tzinfo=datetime.timezone(datetime.timedelta(hours=8))).isoformat()
+
+                o = Order(order_id=data['ord_no'], stock_id=data['stock_no'],
+                          action='BUY' if data['buy_sell'] == 'B' else 'SELL', price=data['mat_price'],
+                          quantity=data['mat_qty'], filled_quantity=data['mat_qty'],
+                          status='FILLED', order_condition=order_condition[data['trade']],
+                          time=time, org_order=None)
+
+                func(o)
+        self.threading = Thread(target=lambda: self.sdk.connect_websocket())
+
+
+
+def create_finlab_order(order):
+    """將 fugle package 的委託單轉換成 finlab 格式"""
+
+    status = OrderStatus.NEW
+    if order['org_qty'] == order['mat_qty']:
+        status = OrderStatus.FILLED
+    elif order['org_qty'] > order['mat_qty'] and order['celable'] == '1' and order['mat_qty'] > 0:
+        status = OrderStatus.PARTIALLY_FILLED
+    elif order['cel_qty'] > 0 or order['err_code'] != '00000000' or order['celable'] == '2':
+        status = OrderStatus.CANCEL
+
+    order_condition = {
+        '0': OrderCondition.CASH,
+        '3': OrderCondition.MARGIN_TRADING,
+        '4': OrderCondition.SHORT_SELLING,
+        '9': OrderCondition.DAY_TRADING_LONG,
+        'A': OrderCondition.DAY_TRADING_SHORT,
+    }[order['trade']]
+
+    filled_quantity = order['mat_qty']
+
+    order_id = order['ord_no']
+    if order_id == '':
+        order_id = order['pre_ord_no']
+
+    return Order(**{
+        'order_id': order_id,
+        'stock_id': order['stock_no'],
+        'action': Action.BUY if order['buy_sell'] == 'B' else Action.SELL,
+        'price': order.get('od_price', order['avg_price']),
+        'quantity': order['org_qty'],
+        'filled_quantity': filled_quantity,
+        'status': status,
+        'order_condition': order_condition,
+        'time': datetime.datetime.strptime(order['ord_date'] + order['ord_time'], '%Y%m%d%H%M%S%f'),
+        'org_order': order
+    })
+
+
+def to_finlab_stock(json_response):
+    """將 fugle 股價行情轉換成 finlab 格式"""
+    r = json_response
+
+    if 'data' not in r:
+        raise Exception('Cannot parse fugle quote data' + str(r))
+
+    if 'order' in r['data']['quote']:
+        bids = r['data']['quote']['order']['bids']
+        asks = r['data']['quote']['order']['asks']
+    else:
+        bids = []
+        asks = []
+
+    has_volume = 'trade' in r['data']['quote']
+    return Stock(
+        stock_id=r['data']['info']['symbolId'],
+        high=r['data']['quote']['priceHigh']['price'] if has_volume else np.nan,
+        low=r['data']['quote']['priceLow']['price'] if has_volume else np.nan,
+        close=r['data']['quote']['trade']['price'] if has_volume else np.nan,
+        open=r['data']['quote']['priceOpen']['price'] if has_volume else np.nan,
+        bid_price=bids[0]['price'] if bids else np.nan,
+        ask_price=asks[0]['price'] if asks else np.nan,
+        bid_volume=bids[0]['volume'] if bids else 0,
+        ask_volume=asks[0]['volume'] if asks else 0,
+    )
+
```

## finlab/online/order_executor.py

```diff
@@ -1,13 +1,16 @@
 from finlab.online.utils import greedy_allocation
 from finlab.online.enums import *
 from finlab import data
+from warnings import warn
 import pandas as pd
 import requests
 import datetime
+import numbers
+import json
 import time
 
 
 class Position():
 
     """使用者可以利用 Position 輕鬆建構股票的部位，並且利用 OrderExecuter 將此部位同步於實際的股票帳戶。
 
@@ -75,25 +78,25 @@
         self.position = []
         for s, a in stocks.items():
             if a != 0:
                 self.position.append(
                     {'stock_id': s, 'quantity': a, 'order_condition': long_order_condition if a > 0 else short_order_condition})
 
     @classmethod
-    def from_dict(cls, position):
+    def from_list(cls, position):
         """利用 `dict` 建構股票部位
 
 
         Attributes:
             position (`list` of `dict`): 股票詳細部位
               ```py
               from finlab.online.enums import OrderCondition
               from finlab.online.order_executor import Position
 
-              Position.from_dict(
+              Position.from_list(
               [{
                   'stock_id': '1101', # 股票代號
                   'quantity': 1.1, # 張數
                   'order_condition': OrderCondition.CASH # 現股融資融券、先買後賣
               }])
 
               ```
@@ -101,25 +104,37 @@
               其中 OrderCondition 除了 `CASH` 外，還有 `MARGIN_TRADING`、`DAY_TRADING_LONG`、`SHORT_SELLING`、`DAY_TRADING_SHORT`。
 
         """
         ret = cls({})
         ret.position = position
         return ret
 
+
+    @classmethod
+    def from_dict(cls, position):
+
+        warn('This method is renamed and will be deprecated.'
+             ' Please replace `Position.from_dict()` to `Position.from_list().`',
+             DeprecationWarning, stacklevel=2)
+
+        ret = cls({})
+        ret.position = position
+        return ret
+
     @classmethod
     def from_weight(cls, weights, fund, price=None, odd_lot=False, board_lot_size=1000, allocation=greedy_allocation):
         """利用 `weight` 建構股票部位
 
         Attributes:
-            weight (`dict` of `float`): 股票詳細部位
+            weights (`dict` of `float`): 股票詳細部位
             fund (number.Number): 資金大小
             price (pd.Series or `dict` of `float`): 股票代號對應到的價格，若無則使用最近個交易日的收盤價。
             odd_lot (bool): 是否考慮零股
             board_lot_size (int): 一張股票等於幾股
-            allocation (func): 資產配置演算法（最大資金部屬貪婪法）
+            allocation (func): 資產配置演算法選定，預設為預設為`finlab.online.utils.greedy_allocation`（最大資金部屬貪婪法）
 
         Examples:
               例如，用 100 萬的資金，全部投入，持有 1101 和 2330 各一半：
               ```py
               from finlab.online.order_executor import Position
 
               Position.from_weight({
@@ -154,39 +169,60 @@
             allocation = greedy_allocation(
                 weights, price*board_lot_size, fund)[0]
 
         return cls(allocation)
 
     @classmethod
     def from_report(cls, report, fund, **kwargs):
-        """利用回測完的報告 `finlab.report.Report` 建構股票部位
+        """利用回測完的報告 `finlab.report.Report` 建構股票部位。
 
         Attributes:
-            report (finlab.report.Report): 回測完的結果報告
-            fund (int): 希望部屬的資金
+            report (finlab.report.Report): 回測完的結果報告。
+            fund (int): 希望部屬的資金。
             price (pd.Series or `dict` of `float`): 股票代號對應到的價格，若無則使用最近個交易日的收盤價。
-            odd_lot (bool): 是否考慮零股
-            board_lot_size (int): 一張股票等於幾股
-            allocation (func): 資產配置演算法（最大資金部屬貪婪法）
+            odd_lot (bool): 是否考慮零股。預設為 False，只使用整張操作。
+            board_lot_size (int): 一張股票等於幾股。預設為1000，一張等於1000股。
+            allocation (func): 資產配置演算法選定，預設為`finlab.online.utils.greedy_allocation`（最大資金部屬貪婪法）。
+        !!! example
+            ```py
+            from finlab import backtest
+            from finlab.online.order_executor import Position
+
+            report1 = backtest.sim(...)
+            report2 = backtest.sim(...)
 
+            position1 = Position.from_report(report1, 1000000) # 策略操作金額一百萬
+            position2 = Position.from_report(report2, 1000000) # 策略操作金額一百萬
+
+            total_position = position1 + position2
+            ```
         """
 
         # next trading date arrived
         tz = datetime.timezone(datetime.timedelta(hours=8))
         next_trading_time = report.next_trading_date.tz_localize(tz) + datetime.timedelta(hours=16)
 
         if datetime.datetime.now(tz) >= next_trading_time:
             w = report.next_weights
         else:
             w = report.weights.copy()
             w.loc[report.actions[report.actions == 'sl_tp_exit'].index] = 0
-            
+
         w = w.groupby(w.index).last()
 
-        return cls.from_weight(weights, fund, **kwargs)
+        return cls.from_weight(w, fund, **kwargs)
+
+    def to_json(self, path):
+        with open(path, 'w') as f:
+            json.dump(self.position, f)
+    
+    @classmethod
+    def from_json(self, path):
+        with open(path, 'r') as f:
+            return json.load(f)
 
     def __add__(self, position):
         return self.for_each_trading_condition(self.position, position.position, "+")
 
     def __sub__(self, position):
         return self.for_each_trading_condition(self.position, position.position, "-")
 
@@ -216,15 +252,15 @@
             # qty2 = {sobj['stock_id']: sobj['quantity']
             #         for sobj in p2 if sobj['order_condition'] == oc}
 
             ps = self.op(qty1, qty2, operator)
             ret += [{'stock_id': sid, 'quantity': round(
                 qty, 3), 'order_condition': oc} for sid, qty in ps.items()]
 
-        return Position.from_dict(ret)
+        return Position.from_list(ret)
 
     @staticmethod
     def op(position1, position2, operator):
         position1 = pd.Series(position1, dtype="float").astype(float)
         position2 = pd.Series(position2, dtype="float").astype(float)
         union_index = position1.index.union(position2.index)
         position1 = position1.reindex(union_index)
@@ -258,15 +294,15 @@
 
 class OrderExecutor():
 
     def __init__(
             self, target_position, account):
         """對比實際帳戶與欲部屬的股票部位，進行同步
             Arguments:
-                target_position (Position): 想要部屬的股票部位
+                target_position (Position): 想要部屬的股票部位。
                 account (Account): 目前支援永豐與富果帳戶，請參考 Account 來實做。
         """
 
         if isinstance(target_position, dict):
             target_position = Position(target_position)
 
         self.account = account
@@ -275,45 +311,53 @@
     def show_alerting_stocks(self):
         """產生下單部位是否有警示股，以及相關資訊"""
 
         present_position = self.account.get_position()
         new_orders = (self.target_position - present_position).position
 
         stock_ids = [o['stock_id'] for o in new_orders]
-        stocks = self.account.get_stocks(stock_ids)
         quantity = {o['stock_id']: o['quantity'] for o in new_orders}
 
         res = requests.get('https://www.sinotrade.com.tw/Stock/Stock_3_8_3')
         dfs = pd.read_html(res.text)
-        credit_sids = dfs[0][dfs[0]['股票代碼'].isin(stock_ids)]['股票代碼']
+        credit_sids = dfs[0][dfs[0]['股票代碼'].astype(str).isin(stock_ids)]['股票代碼']
 
         res = requests.get('https://www.sinotrade.com.tw/Stock/Stock_3_8_1')
         dfs = pd.read_html(res.text)
         credit_sids = pd.concat(
-            [credit_sids, dfs[0][dfs[0]['股票代碼'].isin(stock_ids)]['股票代碼'].astype(str)])
+            [credit_sids, dfs[0][dfs[0]['股票代碼'].astype(str).isin(stock_ids)]['股票代碼'].astype(str)])
         credit_sids.name = None
 
-        for sid in list(credit_sids.values):
-            total_amount = quantity[sid]*stocks[sid].close*1000
-            if quantity[sid] > 0:
-                print(
-                    f"買入 {sid} {quantity[sid]:>5} 張 - 總價約 {total_amount:>15.2f}")
-            else:
-                print(
-                    f"賣出 {sid} {quantity[sid]:>5} 張 - 總價約 {total_amount:>15.2f}")
+        if credit_sids.any():
+            close = data.get('price:收盤價').ffill().iloc[-1]
+            for sid in list(credit_sids.values):
+                if quantity[sid] > 0:
+                    total_amount = quantity[sid]*close[sid]*1000*1.1
+                    print(
+                        f"買入 {sid} {quantity[sid]:>5} 張 - 總價約 {total_amount:>15.2f}")
+                else:
+                    total_amount = quantity[sid]*close[sid]*1000*0.9
+                    print(
+                        f"賣出 {sid} {quantity[sid]:>5} 張 - 總價約 {total_amount:>15.2f}")
 
     def cancel_orders(self):
         """刪除所有未實現委託單"""
         orders = self.account.get_orders()
         for oid, o in orders.items():
             if o.status == OrderStatus.NEW or o.status == OrderStatus.PARTIALLY_FILLED:
                 self.account.cancel_order(oid)
 
     def create_orders(self, market_order=False, best_price_limit=False, view_only=False):
-        """產生委託單，將部位同步成 self.target_position"""
+        """產生委託單，將部位同步成 self.target_position
+        預設以該商品最後一筆成交價設定為限價來下單
+        Attributes:
+            market_order (bool): 以類市價盡量即刻成交：所有買單掛漲停價，所有賣單掛跌停價
+            best_price_limit (bool): 掛芭樂價：所有買單掛跌停價，所有賣單掛漲停價
+            view_only (bool): 預設為 False，會實際下單。若設為 True，不會下單，只會回傳欲執行的委託單資料(dict)。
+        """
 
         present_position = self.account.get_position()
         orders = (self.target_position - present_position).position
 
         if view_only:
             return orders
 
@@ -322,17 +366,21 @@
 
         # make orders
         for o in orders:
 
             if o['quantity'] == 0:
                 continue
 
+            stock = stocks[o['stock_id']]
             action = Action.BUY if o['quantity'] > 0 else Action.SELL
-            price = stocks[o['stock_id']].close
-            if best_price_limit:
+            price = stock.close if isinstance(stock.close, numbers.Number) else (
+                    stock.bid_price if action == Action.BUY else stock.ask_price
+                    )
+
+            if best_price_limit or market_order:
                 limit = 'LOWEST' if action == Action.BUY else 'HIGHEST'
                 print('execute', action, o['stock_id'], 'X', abs(
                     o['quantity']), '@', limit, o['order_condition'])
             else:
                 print('execute', action, o['stock_id'], 'X', abs(
                     o['quantity']), '@', price, o['order_condition'])
```

## finlab/online/sinopac_account.py

```diff
@@ -1,119 +1,102 @@
-from abc import ABC, abstractmethod
-import pandas as pd
 import shioaji as sj
 import datetime
-import numbers
 import time
 import os
 import re
 
 from finlab.online.base_account import Account, Stock, Order, Position
 from finlab.online.enums import *
 
 pattern = re.compile(r'(?<!^)(?=[A-Z])')
 
 
 class SinopacAccount(Account):
-    def __init__(self, account=None, password=None, certificate_password=None, certificate_path=None):
 
-        account = account or os.environ.get('SHIOAJI_ACCOUNT')
-        password = password or os.environ.get('SHIOAJI_PASSWORD')
+    required_module = 'shioaji'
+    module_version = '1.1.2'
+
+    def __init__(self, api_key=None, secret_key=None, 
+                 certificate_person_id=None, 
+                 certificate_password=None, 
+                 certificate_path=None):
+
+        api_key = api_key or os.environ.get('SHIOAJI_API_KEY')
+        secret_key = secret_key or os.environ.get('SHIOAJI_SECRET_KEY')
+
         certificate_password = certificate_password or os.environ.get(
             'SHIOAJI_CERT_PASSWORD')
         certificate_path = certificate_path or os.environ.get(
-            'SHIOAJI_CERT_PATH')
-
-        if certificate_password is None and account is not None:
-            certificate_password = account
-
-        if account is None or password is None or certificate_path is None:
-            self.login()
-            account = account or os.environ.get('SHIOAJI_ACCOUNT')
-            password = password or os.environ.get('SHIOAJI_PASSWORD')
-            certificate_password = certificate_password or os.environ.get(
-                'SHIOAJI_CERT_PASSWORD')
-            certificate_path = certificate_path or os.environ.get(
                 'SHIOAJI_CERT_PATH')
+        certificate_person_id = certificate_person_id or os.environ.get(
+                'SHIOAJI_CERT_PERSON_ID')
 
         self.api = sj.Shioaji()
-        self.accounts = self.api.login(account, password)
-
-        if certificate_path:
-            self.api.activate_ca(
-                ca_path=certificate_path,
-                ca_passwd=certificate_password,
-                person_id=account,
-            )
+        self.accounts = self.api.login(api_key, secret_key)
 
         self.trades = {}
 
-    @staticmethod
-    def login():
-        account = input('Account name not found, please enter account name:\n')
-        password = input('Enter an account password:\n')
-        cert_password = input('Enter an certificate password :\n')
-        cert_path = input('Enter certificate path:\n')
-
-        os.environ['SHIOAJI_ACCOUNT'] = account
-        os.environ['SHIOAJI_PASSWORD'] = password
-        os.environ['SHIOAJI_CERT_PASSWORD'] = cert_password
-        os.environ['SHIOAJI_CERT_PATH'] = cert_path
+        self.api.activate_ca(
+            ca_path=certificate_path,
+            ca_passwd=certificate_password,
+            person_id=certificate_person_id,
+        )
 
     def create_order(self, action, stock_id, quantity, price=None, odd_lot=False, market_order=False, best_price_limit=False, order_cond=OrderCondition.CASH):
 
         contract = self.api.Contracts.Stocks.get(stock_id)
 
         assert quantity > 0
         assert contract is not None
 
         if price == None:
             price = self.api.snapshots([contract])[0].close
 
-        close_price = float(price)
-
         if market_order:
             if action == Action.BUY:
                 price = contract.limit_up
             elif action == Action.SELL:
                 price = contract.limit_down
         elif best_price_limit:
             if action == Action.BUY:
                 price = contract.limit_down
             elif action == Action.SELL:
                 price = contract.limit_up
 
-        price = max(min(close_price * 1.1, price), close_price * 0.9)
-
         if action == Action.BUY:
             action = 'Buy'
         elif action == Action.SELL:
             action = 'Sell'
 
-        first_sell = order_cond == OrderCondition.DAY_TRADING_SHORT
-        first_sell = 'true' if first_sell else 'false'
+        daytrade_short = order_cond == OrderCondition.DAY_TRADING_SHORT
+        daytrade_short = True if daytrade_short else False
 
         order_cond = {
             OrderCondition.CASH: 'Cash',
             OrderCondition.MARGIN_TRADING: 'MarginTrading',
             OrderCondition.SHORT_SELLING: 'ShortSelling',
             OrderCondition.DAY_TRADING_LONG: 'Cash',
             OrderCondition.DAY_TRADING_SHORT: 'Cash'
         }[order_cond]
 
-        order_lot = sj.constant.TFTStockOrderLot.IntradayOdd\
-            if odd_lot else sj.constant.TFTStockOrderLot.Common
+        order_lot = sj.constant.StockOrderLot.IntradayOdd\
+            if odd_lot else sj.constant.StockOrderLot.Common
+        now = datetime.datetime.utcnow() + datetime.timedelta(hours=8)
+        if datetime.time(13,40) < datetime.time(now.hour,now.minute) and datetime.time(now.hour,now.minute) < datetime.time(14,30) and odd_lot:
+            order_lot = sj.constant.StockOrderLot.Odd
+        if datetime.time(14,00) < datetime.time(now.hour,now.minute) and datetime.time(now.hour,now.minute) < datetime.time(14,30) and not odd_lot:
+            order_lot = sj.constant.StockOrderLot.Fixing
 
         order = self.api.Order(price=price,
                                quantity=quantity,
                                action=action,
-                               price_type="LMT",
-                               order_type="ROD",
+                               price_type=sj.constant.StockPriceType.LMT,
+                               order_type=sj.constant.OrderType.ROD,
                                order_cond=order_cond,
-                               first_sell=first_sell,
+                               daytrade_short=daytrade_short,
                                account=self.api.stock_account,
                                order_lot=order_lot,
                                )
         trade = self.api.place_order(contract, order)
 
         self.trades[trade.status.id] = trade
         return trade.status.id
@@ -134,43 +117,104 @@
         position = self.api.list_positions(
             self.api.stock_account, unit=sj.constant.Unit.Share)
         order_conditions = {
             'Cash': OrderCondition.CASH,
             'MarginTrading': OrderCondition.MARGIN_TRADING,
             'ShortSelling': OrderCondition.SHORT_SELLING,
         }
-        return Position.from_dict([{
+        return Position.from_list([{
             'stock_id': p.code,
             'quantity': p.quantity/1000 if p.direction == 'Buy' else -p.quantity/1000,
             'order_condition': order_conditions[p.cond]
         } for p in position])
 
     def get_orders(self):
         self.update_trades()
-        return {t.status.id: Order.from_shioaji(t) for name, t in self.trades.items()}
+        return {t.status.id: trade_to_order(t) for name, t in self.trades.items()}
 
     def get_stocks(self, stock_ids):
         try:
             contracts = [self.api.Contracts.Stocks.get(s) for s in stock_ids]
             snapshots = self.api.snapshots(contracts)
         except:
             time.sleep(10)
             contracts = [self.api.Contracts.Stocks.get(s) for s in stock_ids]
             snapshots = self.api.snapshots(contracts)
 
-        return {s.code: Stock.from_shioaji(s) for s in snapshots}
+        return {s.code: snapshot_to_stock(s) for s in snapshots}
 
     def get_total_balance(self):
         # get bank balance
-        bank_balance = self.api.account_balance()[0].acc_balance
+        bank_balance = self.api.account_balance().acc_balance
 
         # get settlements
-        settlements = self.api.list_settlements(self.api.stock_account)
-        settlements = settlements[0].t_money + \
-            settlements[0].t1_money + settlements[0].t2_money
+        settlements = self.api.settlements(self.api.stock_account)
+        settlements = sum(int(settlement.amount) for settlement in settlements if datetime.datetime.combine(settlement.date, datetime.time(10,0)) > datetime.datetime.now())
 
         # get position balance
         position = self.get_position()
-        stocks = self.get_stocks(position.keys())
-        account_balance = sum(
-            [sobj['quantity'] * stocks[sid].close * 1000 for sid, sobj in position.items()])
+        if position.position:
+            stocks = self.get_stocks([i['stock_id'] for i in position.position])
+            account_balance = sum(
+                [i['quantity'] * stocks[i['stock_id']].close * 1000 for i in position.position])
+        else:
+            account_balance = 0
         return bank_balance + settlements + account_balance
+
+
+def trade_to_order(trade):
+    """將 shioaji package 的委託單轉換成 finlab 格式"""
+    if trade.order.action == 'Buy':
+        action = Action.BUY
+    elif trade.order.action == 'Sell':
+        action = Action.SELL
+    else:
+        raise Exception('trader order action should be "Buy" or "Sell"')
+
+    status = {
+            'PendingSubmit': OrderStatus.NEW,
+            'PreSubmitted': OrderStatus.NEW,
+            'Submitted': OrderStatus.NEW,
+            'Failed': OrderStatus.CANCEL,
+            'Cancelled': OrderStatus.CANCEL,
+            'Filled': OrderStatus.FILLED,
+            'Filling': OrderStatus.PARTIALLY_FILLED,
+            'PartFilled': OrderStatus.PARTIALLY_FILLED,
+            }[trade.status.status]
+
+    order_condition = {
+            'Cash': OrderCondition.CASH,
+            'MarginTrading': OrderCondition.MARGIN_TRADING,
+            'ShortSelling': OrderCondition.SHORT_SELLING,
+            }[trade.order.order_cond]
+
+    # calculate quantity
+    # calculate filled quantity
+    quantity = trade.order.quantity
+    filled_quantity = trade.status.deal_quantity
+
+    if trade.order.order_lot == 'IntradayOdd':
+        quantity /= 1000
+
+    # calculate order condition
+    if trade.order.daytrade_short == True and order_condition == OrderCondition.CASH:
+        order_condition = OrderCondition.DAY_TRADING_SHORT
+
+    return Order(**{
+        'order_id': trade.status.id,
+        'stock_id': trade.contract.code,
+        'action': action,
+        'price': trade.order.price if trade.status.modified_price == 0 else trade.status.modified_price,
+        'quantity': quantity,
+        'filled_quantity': filled_quantity,
+        'status': status,
+        'order_condition': order_condition,
+        'time': trade.status.order_datetime,
+        'org_order': trade
+        })
+
+
+def snapshot_to_stock(snapshot):
+    """將 shioaji 股價行情轉換成 finlab 格式"""
+    d = snapshot
+    return Stock(stock_id=d.code, open=d.open, high=d.high, low=d.low, close=d.close,
+               bid_price=d.buy_price, ask_price=d.sell_price, bid_volume=d.buy_volume, ask_volume=d.sell_volume)
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## finlab/online/utils.py

```diff
@@ -11,14 +11,17 @@
     weights = list(weights.items())
     latest_prices = latest_prices
     if short_ratio is None:
         short_ratio = sum((-x[1] for x in weights if x[1] < 0))
     else:
         short_ratio = short_ratio
 
+    if len(weights) == 0:
+        return {}, total_portfolio_value
+
     """
     Convert continuous weights into a discrete portfolio allocation
     using a greedy iterative approach.
 
     :param reinvest: whether or not to reinvest cash gained from shorting
     :type reinvest: bool, defaults to False
     :param verbose: print error analysis?
```

## finlab/optimize/combinations.py

```diff
@@ -1,11 +1,12 @@
 from itertools import combinations
 import pandas as pd
 from finlab.backtest import sim
 from finlab.report import Report
+from finlab.utils import logger
 
 
 def sim_conditions(conditions, hold_until={}, *args, **kwargs):
     """取得回測報告集合
 
     將選股條件排出所有的組合並進行回測，方便找出最好條件的交集結果。
 
@@ -25,24 +26,23 @@
         from finlab.optimize.combinations import sim_conditions
 
         close = data.get("price:收盤價")
         pe = data.get('price_earning_ratio:本益比')
         rev=data.get('monthly_revenue:當月營收').index_str_to_date()
         rev_ma3=rev.average(3)
         rev_ma12=rev.average(12)
-        營業利益成長率=data.get('fundamental_features:營業利益成長率').deadline()
 
         c1 = (close > close.average(20)) & (close > close.average(60))
         c2 = (close == close.rolling(20).max())
         c3 = pe < 15
         c4 = rev_ma3/rev_ma12 > 1.1
         c5 = rev/rev.shift(1) > 0.9
-        exit = close < close.average(20)
+        exits = close < close.average(20)
         conditions = {'c1':c1, 'c2':c2, 'c3':c3, 'c4':c4, 'c5':c5}
-        report_collection = sim_conditions(conditions=conditions, hold_until={'exit':exit, 'stop_loss':0.1}, resample='M', position_limit=0.1, upload=False)
+        report_collection = sim_conditions(conditions=conditions, hold_until={'exit':exits, 'stop_loss':0.1}, resample='M', position_limit=0.1, upload=False)
         # 策略分組指標報告
         # print(report_collection.stats)
         report_collection.plot_creturns().show()
         report_collection.plot_stats('bar').show()
         report_collection.plot_stats('heatmap')
         ```
         視覺化範例
@@ -73,19 +73,25 @@
     """
     key_dataset = []
     conditions.pop('__builtins__', None)
     for i in range(1, len(conditions) + 1):
         key_dataset.extend(list(combinations(conditions.keys(), i)))
     conditions_combinations = [' & '.join(k) for k in key_dataset]
 
-    if hold_until:
-        reports = {k: sim(eval(k, conditions).hold_until(**hold_until), *args, **kwargs) for k in
-                   conditions_combinations}
-    else:
-        reports = {k: sim(position=eval(k, conditions), *args, **kwargs) for k in conditions_combinations}
+    reports = {}
+    for k in conditions_combinations:
+        if hold_until:
+            position = eval(k, conditions).hold_until(**hold_until)
+        else:
+            position = eval(k, conditions)
+        try:
+            reports[k] = sim(position, *args, **kwargs)
+        except Exception as error:
+            logger.error(f'{k}:{error}')
+            pass
 
     return ReportCollection(reports)
 
 
 class ReportCollection:
     def __init__(self, reports):
         """回測組合比較報告
@@ -119,21 +125,22 @@
         Returns:
           (pd.DataFrame): 策略指標比較報表
         """
 
         def get_strategy_indexes(report):
             if isinstance(report, Report):
                 stats = report.get_stats()
-                strategy_indexes = {n: stats['strategy_indices'][n] for n in
+                trades = report.trades
+                strategy_indexes = {n: stats[n] for n in
                                     ['daily_mean', 'daily_sharpe',
                                      'daily_sortino', 'max_drawdown',
-                                     'avg_drawdown', 'ytd']}
-                trade_indexes = {'win_ratio': stats['trade_indices']['win_ratio']}
+                                     'avg_drawdown']}
+                trade_indexes = {'win_ratio': stats['win_ratio']}
                 trade_indexes.update(
-                    {f'avg_{n}': stats['trade_indices'][n]['mean'] for n in ['return', 'mae', 'bmfe', 'gmfe', 'mdd']})
+                    {f'avg_{n}': trades[n].mean() for n in ['return', 'mae', 'bmfe', 'gmfe', 'mdd']})
                 strategy_indexes.update(trade_indexes)
                 return strategy_indexes
 
         df = pd.DataFrame({k: get_strategy_indexes(v) for k, v in self.reports.items()})
         self.stats = df
         return df
 
@@ -161,19 +168,19 @@
 
             `'avg_score'`: 各指標加總後的平均分數，分數越高為整體評價較正向的策略。
 
             預設以avg_score為排序，數值越大為排名越前面，分數越高為整體評價較優的策略。
 
             ![heatmap](img/optimize/report_collection_stats_heatmap.png)
         """
-        import plotly.graph_objects as go
         if self.stats is None:
             self.get_stats()
         df = self.stats
         if mode == 'bar':
+            import plotly.graph_objects as go
             items = df.columns
             fig = go.Figure(data=[go.Bar(x=df.index, y=df[item], name=item, meta=[item],
                                          hovertemplate="%{meta}<br>%{label}<br>%{y}<extra></extra>") for item in items])
             # Change the bar mode
             fig.update_layout(title={'text': 'Backtest combinations stats', 'x': 0.49, 'y': 0.9, 'xanchor': 'center',
                                      'yanchor': 'top'}, barmode='group')
             return fig
@@ -194,15 +201,16 @@
 
         Examples:
             ![line](img/optimize/report_collection_creturns.png)
         """
         import plotly.graph_objects as go
 
         fig = go.Figure()
-        dataset = self.reports
+        reports = self.reports
+        dataset = {k: v for k, v in sorted(reports.items(), key=lambda item: item[1].creturn[-1], reverse=True)}
         for k, v in dataset.items():
             series = v.creturn
             fig.add_trace(go.Scatter(x=series.index, y=series.values, mode='lines', name=k, meta=k,
                                      hovertemplate="%{meta}<br>Date:%{x}<br>Creturns:%{y}<extra></extra>"))
         fig.update_layout(title={'text': 'Cumulative returns', 'x': 0.49, 'y': 0.9, 'xanchor': 'center',
                                  'yanchor': 'top'})
         return fig
```

## Comparing `finlab-0.3.9.dist-info/LICENSE` & `finlab-0.4.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `finlab-0.3.9.dist-info/METADATA` & `finlab-0.4.0.dist-info/METADATA`

 * *Files 18% similar despite different names*

```diff
@@ -1,113 +1,114 @@
-Metadata-Version: 2.1
-Name: finlab
-Version: 0.3.9
-Summary: Analyzing stock has never been easier.
-Author: FinLab
-Author-email: finlab.company@finlab.tw
-Classifier: Programming Language :: Python :: 3.7
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Classifier: License :: OSI Approved :: GNU General Public License v3 (GPLv3)
-Classifier: Operating System :: OS Independent
-Requires-Python: >=3.6
-Description-Content-Type: text/markdown
-License-File: LICENSE
-Requires-Dist: requests
-Requires-Dist: numpy
-Requires-Dist: pandas (>=1.0.3)
-Requires-Dist: pyarrow (>=2.0.0)
-Requires-Dist: lz4
-Requires-Dist: Cython
-
----
-hide:
-  - navigation
----
-
-# 快速上手
-
-## 安裝
-
-在任意平台上，皆可安裝 FinLab Package，我們支援 Windows、MacOS、Linux，並且甚至是 Pyodide！
-以新手來說，推薦的使用方式是直接在 [Google Colab](https://colab.research.google.com/)，來使用。
-Google Colab 可以線上產生一個執行 Python 的環境，使用者不需額外在本機安裝任何程式，即可開始使用。
-
-=== ":octicons-code-16: FinLab 實驗室"
-    ``` 
-    打開選股策略頁面
-    https://ai.finlab.tw/strategies
-    並點選「建立策略」即可開始使用。
-    ```
-
-=== ":octicons-code-16: Google Colab"
-    ``` py
-    # 打開 Colab: https://colab.research.google.com/ 新增筆記本
-    # 在 Colab 中任意 Cell 中執行
-
-    !pip install finlab > log.txt
-
-    # 即可
-    ```
-
-=== ":octicons-code-16: 本機 Python"
-    ``` py
-    # 在 anacnoda prompt 中執行
-
-    pip install finlab
-    ```
-
-
-## 下載資料
-
-輸入以下程式碼，即可下載資料。可以[查詢](https://ai.finlab.tw/database)有哪些歷史資料可以下載。
-
-``` py
-from finlab import data
-
-data.get('price:收盤價')
-```
-
-| date       |   0015 |   0050 |   0051 |   0052 |   0053 |
-|:-----------|-------:|-------:|-------:|-------:|-------:|
-| 2007-04-23 |   9.54 |  57.85 |  32.83 |  38.4  |    nan |
-| 2007-04-24 |   9.54 |  58.1  |  32.99 |  38.65 |    nan |
-| 2007-04-25 |   9.52 |  57.6  |  32.8  |  38.59 |    nan |
-| 2007-04-26 |   9.59 |  57.7  |  32.8  |  38.6  |    nan |
-| 2007-04-27 |   9.55 |  57.5  |  32.72 |  38.4  |    nan |
-
-## 撰寫策略
-
-可以用非常簡單的 `Pandas` 語法來撰寫策略邏輯，以創新高的策略來說，可以用以下的寫法：
-
-``` py
-from finlab import data
-
-close = data.get('price:收盤價')
-
-# 創三百個交易日新高
-position = close >= close.rolling(300).max()
-position
-```
-
-| date                |   0015 |   0050 |   0051 |   0052 |   0053 |
-|:--------------------|-------:|-------:|-------:|-------:|-------:|
-| 2007-04-23 00:00:00 |  False |  False |  False |  False |  False |
-| 2007-04-24 00:00:00 |  False |  False |  False |  False |  False |
-| 2007-04-25 00:00:00 |  False |  False |  False |  False |  False |
-| 2007-04-26 00:00:00 |  False |  False |  False |   True |  False |
-| 2007-04-27 00:00:00 |  False |  False |  False |  False |  False |
-
-這邊的 `position` 是一個 False/True 的查詢表，當數值為 True ，代表該股票在當天有創新高，而數字 False 則代表沒有創新高。由於創新高的股票很少，上面的範例中，只有少數股票的數值會是 True。
-
-假設我們希望每個月底，搜尋上表中數值為 True 的股票並且買入持有一個月，可以用以下的語法：
-
-## 回測績效
-
-``` py
-from finlab import backtest
-
-report = backtest.sim(position, resample='M')
-```
-
-![image](https://i.ibb.co/7kNyvhP/Screen-Shot-2021-07-13-at-11-54-29-PM.png)
+Metadata-Version: 2.1
+Name: finlab
+Version: 0.4.0
+Summary: Analyzing stock has never been easier.
+Author: FinLab
+Author-email: finlab.company@finlab.tw
+Classifier: Programming Language :: Python :: 3.7
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: License :: OSI Approved :: GNU General Public License v3 (GPLv3)
+Classifier: Operating System :: OS Independent
+Requires-Python: >=3.7
+Description-Content-Type: text/markdown
+License-File: LICENSE
+Requires-Dist: requests
+Requires-Dist: numpy (>=1.21.6)
+Requires-Dist: pandas (>=1.0.3)
+Requires-Dist: pyarrow (>=2.0.0)
+Requires-Dist: lz4
+Requires-Dist: Cython
+Requires-Dist: tqdm
+
+---
+hide:
+  - navigation
+---
+
+# 快速上手
+
+## 安裝
+
+在任意平台上，皆可安裝 FinLab Package，我們支援 Windows、MacOS、Linux，並且甚至是 Pyodide！
+以新手來說，推薦的使用方式是直接在 [Google Colab](https://colab.research.google.com/)，來使用。
+Google Colab 可以線上產生一個執行 Python 的環境，使用者不需額外在本機安裝任何程式，即可開始使用。
+
+=== ":octicons-code-16: FinLab 實驗室"
+    ``` 
+    打開選股策略頁面
+    https://ai.finlab.tw/strategies
+    並點選「建立策略」即可開始使用。
+    ```
+
+=== ":octicons-code-16: Google Colab"
+    ``` py
+    # 打開 Colab: https://colab.research.google.com/ 新增筆記本
+    # 在 Colab 中任意 Cell 中執行
+
+    !pip install finlab > log.txt
+
+    # 即可
+    ```
+
+=== ":octicons-code-16: 本機 Python"
+    ``` py
+    # 在 anacnoda prompt 中執行
+
+    pip install finlab
+    ```
+
+
+## 下載資料
+
+輸入以下程式碼，即可下載資料。可以[查詢](https://ai.finlab.tw/database)有哪些歷史資料可以下載。
+
+``` py
+from finlab import data
+
+data.get('price:收盤價')
+```
+
+| date       |   0015 |   0050 |   0051 |   0052 |   0053 |
+|:-----------|-------:|-------:|-------:|-------:|-------:|
+| 2007-04-23 |   9.54 |  57.85 |  32.83 |  38.4  |    nan |
+| 2007-04-24 |   9.54 |  58.1  |  32.99 |  38.65 |    nan |
+| 2007-04-25 |   9.52 |  57.6  |  32.8  |  38.59 |    nan |
+| 2007-04-26 |   9.59 |  57.7  |  32.8  |  38.6  |    nan |
+| 2007-04-27 |   9.55 |  57.5  |  32.72 |  38.4  |    nan |
+
+## 撰寫策略
+
+可以用非常簡單的 `Pandas` 語法來撰寫策略邏輯，以創新高的策略來說，可以用以下的寫法：
+
+``` py
+from finlab import data
+
+close = data.get('price:收盤價')
+
+# 創三百個交易日新高
+position = close >= close.rolling(300).max()
+position
+```
+
+| date                |   0015 |   0050 |   0051 |   0052 |   0053 |
+|:--------------------|-------:|-------:|-------:|-------:|-------:|
+| 2007-04-23 00:00:00 |  False |  False |  False |  False |  False |
+| 2007-04-24 00:00:00 |  False |  False |  False |  False |  False |
+| 2007-04-25 00:00:00 |  False |  False |  False |  False |  False |
+| 2007-04-26 00:00:00 |  False |  False |  False |   True |  False |
+| 2007-04-27 00:00:00 |  False |  False |  False |  False |  False |
+
+這邊的 `position` 是一個 False/True 的查詢表，當數值為 True ，代表該股票在當天有創新高，而數字 False 則代表沒有創新高。由於創新高的股票很少，上面的範例中，只有少數股票的數值會是 True。
+
+假設我們希望每個月底，搜尋上表中數值為 True 的股票並且買入持有一個月，可以用以下的語法：
+
+## 回測績效
+
+``` py
+from finlab import backtest
+
+report = backtest.sim(position, resample='M')
+```
+
+![image](https://i.ibb.co/7kNyvhP/Screen-Shot-2021-07-13-at-11-54-29-PM.png)
```

## Comparing `finlab-0.3.9.dist-info/RECORD` & `finlab-0.4.0.dist-info/RECORD`

 * *Files 20% similar despite different names*

```diff
@@ -1,34 +1,45 @@
-finlab/__init__.py,sha256=0fYJh3ThcOI7lZ4EUPtCuoG5Ce7VgxhPWWQbkW_o7Fs,2135
-finlab/aes.cp39-win_amd64.pyd,sha256=nbg34B6O3Hw4RB_j3Y1K_jdfop3UB-n9QhSdgQxDEfI,202752
-finlab/backtest.py,sha256=WYu5Er5AQiHHoY0-2QwVqTZyV9G1-P_KoEGnsBYN3Fs,22051
-finlab/backtest_core.cp39-win_amd64.pyd,sha256=6-SQB4jqWa5EIcSzQQFIq2-gzcBFGCo8jT6RbtvXAvc,130560
+finlab/__init__.py,sha256=v3xA_0-CfbIsGRjNXUtaL26mStz19mTJJqnulhYqgzA,2450
+finlab/aes.cp39-win_amd64.pyd,sha256=NWjBzTz0pQaeb5XR9m-CJo9v6SfkYDrZgvwaGAzNAKo,206848
+finlab/backtest.py,sha256=kygH80sAtWPwSeAKJmvdKa5dALcBHXeDSGZv_BD4dO4,22598
+finlab/backtest_core.cp39-win_amd64.pyd,sha256=X-E8_1Czecd_8Nc1JQhl_Jys_JdZ-FAMuZHnR5HlwPw,133632
 finlab/backtest_old.py,sha256=7K66Z0BkT1zsLc4F6POlLrVF7khPVhLXL69wRgE3ay8,1424
 finlab/cells.py,sha256=nRlhr8mvdViA7P8d9rHtCYe8tqbY8gVHzHsvzhY9TCo,915
-finlab/data.py,sha256=V9buGFoSgJ46dknCp8lvTOy-iNBW9NdD_g9UP_uy8x4,24735
-finlab/dataframe.py,sha256=7okx8zkLglT09c_6HAAyPN5Fqnk12IKoNzoSFMMSHpk,27138
-finlab/ffn_core.py,sha256=ebkQROSZO4cKWyhETLKmpMoD2TPp7pYHEQlLeq4eExs,80714
-finlab/mae_mfe.cp39-win_amd64.pyd,sha256=gpTs6vzlb8B-xf-oRNi_-k_QOiggQsxdtweMx12NOhk,72704
+finlab/data.py,sha256=26ZM5fMR7IUNvQLcR2QwxuDRhbgvrqUBauvfFZXdIJ8,29089
+finlab/dataframe.py,sha256=Lc0UfvBof3YMk8yp4HXOIAjEV4s3BByENrwi-RX2xK4,29056
+finlab/ffn_core.py,sha256=LTHkl6HVzkhUlMPqNGqEkN92ux7Q7VOXlljWIM41N0o,80750
+finlab/mae_mfe.cp39-win_amd64.pyd,sha256=kt9QJAPKUNlvTCRnQh2Zvn9ptq4UVJLOYoPIYJr32mE,73216
 finlab/mae_mfe.pxd,sha256=Lmf_StbLnzvQhIxqae_V47MOFgp_IsylFmgmVdnwIFg,460
-finlab/market_info.py,sha256=ZsR2a9ufG2lwau8n8iIyjL9SpWJCRlMx5TllUuaVpBM,4216
-finlab/plot.py,sha256=sO9C0fff07UoLQkkswymKH8VkbaenByVPPOWjgsempI,36481
-finlab/report.cp39-win_amd64.pyd,sha256=44NNHpO72oEJss9VZjR6qYppcxvNXX1VFV4I7d1Cxi0,228864
+finlab/market_info.py,sha256=iDoKgbcZ2EHvv0pJmuv1s-3w14UrCcJjeA3sm67FNTw,3757
+finlab/plot.py,sha256=MMwN-XHULVYb7AF0ntaunujRwEZM3il_1cySMZ3lN1A,36059
+finlab/report.cp39-win_amd64.pyd,sha256=ky0kNZBAGOjoqSswylJy4kfhuQR3CCOgkG3F87bnol8,166912
 finlab/utils.py,sha256=QVttpM6h85PggRsRIMXs44kMz9ktsyoKgbnKkRPm1Jg,5132
-finlab/utils_core.cp39-win_amd64.pyd,sha256=dnqSliiccRQ38nJEIlnTbRsnnvxxzq80QdDRHpwLmOc,19968
-finlab/analysis/__init__.py,sha256=SuEgqJ8kNoHPXw7dk9PZKexlPgkbCGLba_7jgGaaBH0,7426
+finlab/utils_core.cp39-win_amd64.pyd,sha256=jBBwbylMaEYmnaKyLV2O68DoKol7kBstnGBnUpt5yLM,19968
+finlab/analysis/__init__.py,sha256=YboGTgUSD6RRHD4p58FT3hB_DerT6T_vNlWXlNCJbsg,7287
+finlab/analysis/alphaBetaAnalysis.py,sha256=6ixBH9JT4ERx_i5qTuumr3-WgJhp4upsJEZgbzGe2Nc,1988
+finlab/analysis/drawdownAnalysis.py,sha256=B9lhGVwBkwbJCfg8ac0xVk9EoaErB1x0prmz9q7_A7s,1449
 finlab/analysis/inequalityAnalysis.py,sha256=PuE11Eloz22SSBlLURmzO9CBAx5fnEX1_qa5IKUp70Q,5007
-finlab/analysis/liquidityAnalysis.py,sha256=k4JDuDLho3y7LN9seRSuh_TBbg4x4B_Xgac3JSnk09k,4395
+finlab/analysis/liquidityAnalysis.py,sha256=YlpYg52TWZ6d_gmCTAGjcaaHtZ3iwsoKdUpptrs_QBw,4626
+finlab/analysis/maeMfeAnalysis.py,sha256=sWPvaRRLmZN1FU7qWjedpI0PhXdZVhhC7UUJyg-71Is,12343
+finlab/analysis/periodStatsAnalysis.py,sha256=ECB91mTNvM3sjB_WfwGU_8W3iadQYGcfL-vVE2a0Pss,3618
+finlab/ml/__init__.py,sha256=oV4GCvyk_mXbfhR0cH5CzDn970EVlYhS8sSUh0KIkpY,704
+finlab/ml/feature.py,sha256=mw1SuL85CksPb8Sbs-Uw0noPg-TvEkM7iGQ95xouMIM,15448
+finlab/ml/label.py,sha256=1s9_ir8KmGJKqiXut3kMIaa5JzbGWTt3adlGXdRC5cU,2404
+finlab/ml/qlib.py,sha256=GjQHtUTc_wO7nUOtffw6Bi5WxMelNuV1DiWKxIdi0sM,17707
+finlab/ml/utils.py,sha256=UiKIfL69zREH9GrOP_MRQxUA162D9PzHRqXSEj64odI,3131
 finlab/online/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-finlab/online/base_account.py,sha256=p0fxIWSkqCOmqgTS1SlSV_hXGF4j6DSUEKZdy_96oJE,10983
-finlab/online/enums.py,sha256=hZEoTK07b-60iOC_2uzH-v_dS63GTj5fNX6AKtwkG9M,252
-finlab/online/fugle_account.py,sha256=1gabsl_2nJpGMvQZ8mG3CoZBwGJsYCfmu4k4cpSmloc,6170
-finlab/online/order_executor.py,sha256=OqKol9zzxBX59HiLuNjIaNrvgXrDal6omgk_O33I-9g,14940
+finlab/online/base_account.py,sha256=PiIQjIgjTf6fcYtlbWevwZ_T40qvwpBjesdecvWd1ok,8155
+finlab/online/binance_account.py,sha256=bxTsx1sI1BDnx1OKWAxTvWm96-BGsWCrxQNOHszJ1Xg,12766
+finlab/online/dashboard.py,sha256=hhLoQDgytda4xW_wOLb3rlOO_j_W5aILlwjNrKwX2QI,7264
+finlab/online/enums.py,sha256=7X5VmoaffdVDFNiRF-EIeRBtroGmLGEryVlxLmurWro,263
+finlab/online/fugle_account.py,sha256=CJDlalFoyJUlQ2ENsNDEu9DNxG9kfENBO8DiqVsGGlM,12824
+finlab/online/order_executor.py,sha256=KcbPv1b79c5hLsg36yvVI5BjP9hrQ1DZC62QZ4drfhs,17102
 finlab/online/panel.py,sha256=pL7vHsZfmNYI0LqZN-2amZgPXyViznUqNCzQTZVz170,13122
-finlab/online/sinopac_account.py,sha256=BhB9CUAQv823EaAW-oGaXyTiTkCDHQK8v6BTuHacGmM,6697
-finlab/online/utils.py,sha256=k93Jl4JLPf0wXYh_4MVEysmWcS9oWmH_t5IMZlPVHXo,5361
+finlab/online/sinopac_account.py,sha256=fp4DaWFaHof93yqhDuZXwBeFP2KRFVjQOdk0VtriH-M,8537
+finlab/online/utils.py,sha256=CiLEnPvB5e94eNKaOISe0b1-YG_JHhJF5LYpRyWoN_o,5432
 finlab/optimize/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-finlab/optimize/combinations.py,sha256=jfpfDkXbC9P04jglMCBHJiKZPuCqcyIkL5QhPMqf2qA,8687
-finlab-0.3.9.dist-info/LICENSE,sha256=IwGE9guuL-ryRPEKi6wFPI_zOhg7zDZbTYuHbSt_SAk,35823
-finlab-0.3.9.dist-info/METADATA,sha256=EhudZkXsw2NVDxVyXK_ZFRKKb3VPzHLWe3eiQQSBpEk,3642
-finlab-0.3.9.dist-info/WHEEL,sha256=fVcVlLzi8CGi_Ul8vjMdn8gER25dn5GBg9E6k9z41-Y,100
-finlab-0.3.9.dist-info/top_level.txt,sha256=m5gMT8MS1RxoL-WPzxP83LozK_ubRB3AN7d9shpXNIQ,7
-finlab-0.3.9.dist-info/RECORD,,
+finlab/optimize/combinations.py,sha256=3KSMgffs6QJUcLBg_0gMbdrjxBKoix9gU9xlsmLmud4,8815
+finlab-0.4.0.dist-info/LICENSE,sha256=IwGE9guuL-ryRPEKi6wFPI_zOhg7zDZbTYuHbSt_SAk,35823
+finlab-0.4.0.dist-info/METADATA,sha256=Lh1di8KWXA9otBmUPEGeu9s899p0KrgRrnLocqNFmwU,3787
+finlab-0.4.0.dist-info/WHEEL,sha256=eep6QWEFiQfg2wcclssb_WY-D33AnLYLnEKGA9Rn-VU,100
+finlab-0.4.0.dist-info/top_level.txt,sha256=m5gMT8MS1RxoL-WPzxP83LozK_ubRB3AN7d9shpXNIQ,7
+finlab-0.4.0.dist-info/RECORD,,
```

